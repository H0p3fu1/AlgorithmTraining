# 环境配置

- LeetCode官方题单

- CLion

- CLion LeetCode插件

# 算法基础

## 数与位

### 位运算库函数

```
__builtin_ctz(8);       // 返回二进制中后导0的个数
__builtin_clz(8);       // 返回二进制中前导0的个数
__builtin_popcount(8)   // 返回二进制数中1的个数
__builtin_parity(8);    // 返回二进制数中1的奇偶性
```

### 最大公因数

[1071. 字符串的最大公因子](https://leetcode.cn/problems/greatest-common-divisor-of-strings/)

```
// C++17内置函数
int gcd(int a, int b) {
    return std::gcd(a, b);
}

// 递归实现
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}

// 辗转相除法
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

string gcdOfStrings(string str1, string str2) {
    if (str1 + str2 != str2 + str1) {
        return "";
    }
    return str1.substr(0, gcd(str1.length(), str2.length()));
}
```

### 最小公倍数

```
int lcm(int a, int b) {
    return a * b / std::gcd(a, b);
}
```

### 判断质数

```
bool isPrime(int x) {
    for (int i = 2; i * i <= x; ++i) {
        if (x % i == 0) {
            return false;
        }
    }
    return true;
}
```

[204. 计数质数](https://leetcode.cn/problems/count-primes/)

```
int countPrimes(int n) {
    vector<bool> isPrime(n, true);
    int result = 0;
    for (int i = 2; i < n; ++i) {
        if (isPrime[i]) {
            result += 1;
            // 应该直接从 x*x 开始标记，因为2x ,3x ,... 些数一定在 x 之前就被其他数的倍数标记过了。
            for (long long j = (long long) i * i; j < n; j += i) {
                isPrime[j] = false;
            }
        }
    }
    return result;
}
```

### 字符串转整数溢出处理

    // 10 * number + digit > INT_MAX => number > (INT_MAX - digit) / 10
    int digit = s[i] - '0';
    if (number > (INT_MAX - digit) / 10){
    	return sign == 1 ? INT_MAX : INT_MIN;
    }
    number = 10 * number + (s[i] - '0');

### 进制转换

[504. 七进制数](https://leetcode.cn/problems/base-7/)

```
string convertToBase7(int num) {
    if (!num) {
        return "0";
    }
    bool negative = num < 0;
    num = negative ? -num : num;
    string result;
    while (num) {
        result = to_string(num % 7) + result;
        num /= 7;
    }
    return negative ? "-" + result : result;
}
```

### 下一个排列

[31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

```
void nextPermutation(vector<int> &nums) {
    int i = nums.size() - 2;
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }
    if (i >= 0) {
        int j = nums.size() - 1;
        while (j >= 0 && nums[j] <= nums[i]) {
            j--;
        }
        if (j >= 0) {
            swap(nums[i], nums[j]);
        }
    }
    reverse(nums.begin() + i + 1, nums.end());
}
```

[556. 下一个更大元素 III](https://leetcode.cn/problems/next-greater-element-iii/)

```
int nextGreaterElement(int n) {
    auto nums = to_string(n);
    int i = (int) nums.length() - 2;
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }
    if (i < 0) {
        return -1;
    }

    int j = nums.size() - 1;
    while (j >= 0 && nums[i] >= nums[j]) {
        j--;
    }
    swap(nums[i], nums[j]);
    reverse(nums.begin() + i + 1, nums.end());
    long ans = stol(nums);
    return ans > INT_MAX ? -1 : ans;
}
```

### 完全平方数

[367. 有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

```
bool isPerfectSquare(int num) {
    int left = 0;
    int right = num;
    while (left <= right) {
        int mid = (right - left) / 2 + left;
        long long square = mid * mid;
        if (num == square) {
            return true;
        } else if (num < square) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return false;
}
```

### 回文数

[9. 回文数](https://leetcode.cn/problems/palindrome-number/)

```
bool isPalindrome(int x) {
    if (x < 0 || (x != 0 && x % 10 == 0)) {
        return false;
    }
    int reverse = 0;
    while (x > reverse) {
        reverse = reverse * 10 + x % 10;
        x /= 10;
    }
    return x == reverse || x == reverse / 10;
}
```

### 汉明距离

[461. 汉明距离](https://leetcode.cn/problems/hamming-distance/)

```
// C++内置函数
int hammingDistance(int x, int y) {
    return __builtin_popcount(x ^ y);
}

// 迭代
int hammingDistance(int x, int y) {
	int result = 0;
    int s = x ^ y;
    while (s) {
        result += s & 1;
        s >>= 1;
    }
    return result;
}

// Brian Kernighan 算法
int hammingDistance(int x, int y) {
    int result = 0;
    int s = x ^ y;
    while (s) {
        s &= s - 1;
        result++;
    }
    return result;
}
```

### 数字范围按位与

[201. 数字范围按位与](https://leetcode.cn/problems/bitwise-and-of-numbers-range/)

```
int rangeBitwiseAnd(int left, int right) {
    while (left < right) {
        right &= right - 1;
    }
    return right;
}
```

### 两数之和

两整数之和（[371. 两整数之和](https://leetcode.cn/problems/sum-of-two-integers/)）

```
int getSum(int a, int b) {
    while (b) {
        unsigned int c = (a & b) << 1;
        a ^= b;
        b = c;
    }
    return a;
}
```

### 只出现一次的数字

[136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

```
int singleNumber(vector<int> &nums) {
    int result = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        result ^= nums[i];
    }
    return result;
}
```

[260. 只出现一次的数字 III](https://leetcode.cn/problems/single-number-iii/)

```
vector<int> singleNumber(vector<int> &nums) {
    unsigned int sum = 0;
    for (int i = 0; i < nums.size(); i++) {
        sum ^= nums[i];
    }

    vector<int> result(2);
    int bit = sum & -sum;
    for (int i = 0; i < nums.size(); i++) {
        result[(nums[i] & bit) != 0] ^= nums[i];
    }
    return result;
}
```

## 数组

### 查找数组元素

[448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)

```
// 若不允许修改原数组，则不存在O(1)空间复杂度的方法
vector<int> findDisappearedNumbers(vector<int> &nums) {
    int n = nums.size();
    for (int i = 0; i < n; i++) {
        // 防止溢出
        if (nums[(nums[i] - 1) % n] <= n) {
            nums[(nums[i] - 1) % n] += n;
        }
    }

    vector<int> ans;
    for (int i = 0; i < n; i++) {
        if (nums[i] <= n) {
            ans.push_back(i + 1);
        }
    }
    return ans;
}
```

[442. 数组中重复的数据](https://leetcode.cn/problems/find-all-duplicates-in-an-array/)

```
vector<int> findDuplicates(vector<int> &nums) {
    int n = nums.size();
    for (int i = 0; i < n; i++) {
        nums[(nums[i] - 1) % n] += n;
    }

    vector<int> ans;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] > 2 * n) {
            ans.push_back(i + 1);
        }
    }
    return ans;
}
```

[41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

```
int firstMissingPositive(vector<int> &nums) {
    int n = nums.size();
    for (int i = 0; i < n; i++) {
        if (nums[i] <= 0 || nums[i] > n) {
            nums[i] = n + 1;
        }
    }

    for (int i = 0; i < n; i++) {
        int num = abs(nums[i]);
        if (num <= n) {
            nums[num - 1] = -abs(nums[num - 1]);
        }
    }

    for (int i = 0; i < n; i++) {
        if (nums[i] > 0) {
            return i + 1;
        }
    }

    return n + 1;
}
```

### 数组变换

[189. 轮转数组](https://leetcode.cn/problems/rotate-array/)

```C++
void rotate(vector<int>& nums, int k) {
    k %= nums.size();
    reverse(nums.begin(), nums.end());
    reverse(nums.begin(), nums.begin() + k);
    reverse(nums.begin() + k, nums.end());
}
```

### 矩阵遍历

[118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

```
vector<vector<int> > generate(int numRows) {
    vector<vector<int> > res(numRows, vector<int>());
    for (int i = 0; i < numRows; i++) {
        res[i].resize(i + 1, 1);
    }
    for (int i = 1; i < numRows; i++) {
        for (int j = 1; j < i; j++) {
            res[i][j] = res[i - 1][j - 1] + res[i - 1][j];
        }
    }
    return res;
}
```

[119. 杨辉三角 II](https://leetcode.cn/problems/pascals-triangle-ii/)

```
vector<int> getRow(int rowIndex) {
    vector<vector<int> > res(rowIndex + 1, vector<int>());
    for (int i = 0; i < rowIndex + 1; i++) {
        res[i].resize(i + 1, 1);
    }
    for (int i = 1; i < rowIndex + 1; i++) {
        for (int j = 1; j < i; j++) {
            res[i][j] = res[i - 1][j - 1] + res[i - 1][j];
        }
    }
    return res[rowIndex];
}
```

[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```
vector<int> spiralOrder(vector<vector<int> > &matrix) {
    int rows = matrix.size(), columns = matrix[0].size();
    vector<int> order;
    int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
    while (left <= right && top <= bottom) {
        for (int column = left; column <= right; column++) {
            order.push_back(matrix[top][column]);
        }
        for (int row = top + 1; row <= bottom; row++) {
            order.push_back(matrix[row][right]);
        }
        if (left < right && top < bottom) {
            for (int column = right - 1; column > left; column--) {
                order.push_back(matrix[bottom][column]);
            }
            for (int row = bottom; row > top; row--) {
                order.push_back(matrix[row][left]);
            }
        }
        left++;
        right--;
        top++;
        bottom--;
    }
    return order;
}
```

[59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

```
vector<vector<int> > generateMatrix(int n) {
    vector<vector<int> > matrix(n, vector<int>(n, 0));
    int left = 0, right = n - 1, top = 0, bottom = n - 1;
    int number = 1;
    while (left <= right && top <= bottom) {
        for (int column = left; column <= right; column++) {
            matrix[top][column] = number++;
        }
        for (int row = top + 1; row <= bottom; row++) {
            matrix[row][right] = number++;
        }
        if (left < right && top < bottom) {
            for (int column = right - 1; column > left; column--) {
                matrix[bottom][column] = number++;
            }
            for (int row = bottom; row > top; row--) {
                matrix[row][left] = number++;
            }
        }
        left++;
        right--;
        top++;
        bottom--;
    }
    return matrix;
}
```

[498. 对角线遍历](https://leetcode.cn/problems/diagonal-traverse/)

```
vector<int> findDiagonalOrder(vector<vector<int> > &mat) {
    int m = mat.size();
    int n = mat[0].size();
    vector<int> res;
    for (int i = 0; i < m + n - 1; i++) {
        if (i % 2) {
            int x = i < n ? 0 : i - n + 1;
            int y = i < n ? i : n - 1;
            while (x < m && y >= 0) {
                res.emplace_back(mat[x++][y--]);
            }
        } else {
            int x = i < m ? i : m - 1;
            int y = i < m ? 0 : i - m + 1;
            while (x >= 0 && y < n) {
                res.emplace_back(mat[x--][y++]);
            }
        }
    }
    return res;
}
```

### 矩阵变换

[48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

```C++
void rotate(vector<vector<int> > &matrix) {
    for (int i = 0; i < matrix.size(); i++) {
        for (int j = i + 1; j < matrix[i].size(); j++) {
            swap(matrix[i][j], matrix[j][i]);
        }
    }
}
```

[867. 转置矩阵](https://leetcode.cn/problems/transpose-matrix/)

```
vector<vector<int> > transpose(vector<vector<int> > &matrix) {
    vector<vector<int> > result(matrix[0].size(), vector<int>(matrix.size()));
    for (int i = 0; i < matrix.size(); i++) {
        for (int j = 0; j < matrix[i].size(); j++) {
            result[j][i] = matrix[i][j];
        }
    }
    return result;
}
```

### 前缀和

[303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

```C++
class NumArray {
private:
    vector<int> sums;
public:
    NumArray(vector<int> &nums) {
        int n = nums.size();
        sums.resize(n + 1);
        for (int i = 0; i < n; i++) {
            sums[i + 1] = sums[i] + nums[i];
        }
    }

    int sumRange(int left, int right) {
        return sums[j + 1] - sums[i];
    }
};
```

[304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

```C++
class NumMatrix {
private:
    vector<vector<int> > sums;
public:
    NumMatrix(vector<vector<int> > &matrix) {
        sums.resize(matrix.size() + 1, vector<int>(matrix[0].size() + 1, 0));
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size(); j++) {
                sums[i + 1][j + 1] = sums[i + 1][j] + sums[i][j + 1] - sums[i][j] + matrix[i][j];
            }
        }
    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        return sums[row2 + 1][col2 + 1] - sums[row1][col2 + 1] - sums[row2 + 1][col1] + sums[row1][col1];
    }
};
```

## 链表

### 头节点

```c++
// 必要时可增加头节点简化操作
ListNode dummy(0, head);
```

### 遍历

```
void traversal(ListNode *head) {
    ListNode *current = head;
    while (current) {
        // 执行操作
        current = current->next;
    }
}
```

### 插入

```
// 头插法
ListNode *insertNode(ListNode *head, ListNode *node) {
    ListNode dummy(0, head);
    ListNode *previous = &dummy;
    previous->next = node;
    return dummy.next;
}

// 尾插法
ListNode *insertNode(ListNode *head, ListNode *node) {
    ListNode *tail = head;
    while (tail->next) {
        tail = tail->next;
    }
    tail->next = node;
    return head;
}
```

### 删除

[203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

```
ListNode *removeElements(ListNode *head, int val) {
    ListNode dummy(0, head);
    ListNode *previous = &dummy;
    ListNode *current = head;
    while (current) {
        if (current->val == val) {
            previous->next = current->next;
            delete current;
            current = previous->next;
        } else {
            previous = current;
            current = current->next;
        }
    }
    return dummy.next;
}
```

### 反转

[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```C++
// 迭代版本（头插法）
ListNode *reverseList(ListNode *head) {
    ListNode *previous = nullptr;
    ListNode *current = head;
    while (curr) {
        ListNode *next = current->next;
        current->next = previous;
        previous = current;
        current = next;
    }
    return prev;
}

// 递归版本
ListNode *reverseList(ListNode *head) {
    if (!head || !head->next) {
        return head;
    }
    ListNode *reversed = reverseList(head->next);
    head->next->next = head;
    head->next = nullptr;
    return reversed;
}
```

### 合并

[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

```
ListNode *mergeTwoLists(ListNode *list1, ListNode *list2) {
    ListNode head;
    ListNode *tail = &head;
    while (list1 && list2) {
        if (list1->val <= list2->val) {
            tail->next = list1;
            list1 = list1->next;
        } else {
            tail->next = list2;
            list2 = list2->next;
        }
        tail = tail->next;
    }

    if (list1) {
        tail->next = list1;
    }
    if (list2) {
        tail->next = list2;
    }

    return head.next;
}
```

[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

```
ListNode *mergeKLists(vector<ListNode *> &lists) {
    auto compare = [](ListNode *a, ListNode *b) { return a->val > b->val; };
    priority_queue<ListNode *, vector<ListNode *>, decltype(compare)> queue(compare);
    for (auto &node: lists) {
        if (node) {
            queue.push(node);
        }
    }
    ListNode head;
    ListNode *tail = &head;
    while (!queue.empty()) {
        ListNode *node = queue.top();
        queue.pop();
        tail->next = node;
        tail = tail->next;
        if (node->next) {
            queue.push(node->next);
        }
    }
    return head.next;
}
```

### 双指针

[86.  分隔链表](https://leetcode.cn/problems/partition-list/)

```
ListNode *partition(ListNode *head, int x) {
    ListNode lhead(0, head);
    ListNode *ltail = &lhead;

    ListNode rhead(0, head);
    ListNode *rtail = &rhead;

    while (head) {
        if (head->val < x) {
            ltail->next = head;
            ltail = ltail->next;
        } else {
            rtail->next = head;
            rtail = rtail->next;
        }
        head = head->next;
    }
    rtail->next = nullptr;
    ltail->next = rhead.next;

    return lhead.next;
}
```

[19. 删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```
ListNode *removeNthFromEnd(ListNode *head, int n) {
    ListNode dummy(0, head);
    ListNode *slow = &dummy;
    ListNode *fast = head;
    for (int i = 0; i < n; i++) {
        fast = fast->next;
    }
    while (fast) {
        fast = fast->next;
        slow = slow->next;
    }
    ListNode *node = slow->next;
    slow->next = slow->next->next;
    delete node;
    return dummy.next;
}
```

[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

```C++
// 写法一（链表长度为奇数时slow指向中点，链表长度为偶数时slow指向后半部分开头）
ListNode *middleNode(ListNode *head) {
    ListNode *slow = head;
    ListNode *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}

// 写法二（链表长度为奇数时slow指向中点，链表长度为偶数时slow指向前半部分结尾）
ListNode *middleNode(ListNode *head) {
    ListNode *slow = head;
    ListNode *fast = head;
    while (fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return fast->next ? slow->next : slow;
}
```

[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

```
ListNode *reverse(ListNode *head) {
    ListNode *previous = nullptr;
    ListNode *current = head;
    while (current) {
        ListNode *next = current->next;
        current->next = previous;
        previous = current;
        current = next;
    }
    return previous;
}

bool isPalindrome(ListNode *head) {
    if (!head) {
        return true;
    }
    ListNode *slow = head;
    ListNode *fast = head;
    while (fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    ListNode *mid = reverse(slow->next);
    ListNode *p = head;
    ListNode *q = mid;
    while (p && q && p->val == q->val) {
        p = p->next;
        q = q->next;
    }
    slow->next = reverse(mid);
    return !q;
}
```

[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

```C++
bool hasCycle(ListNode *head) {
    ListNode *slow = head;
    ListNode *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
```

[142. 环形链表Ⅱ](https://leetcode.cn/problems/linked-list-cycle-ii/)

```
ListNode *detectCycle(ListNode *head) {
    ListNode *slow = head;
    ListNode *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            ListNode *node = head;
            while (node != slow) {
                slow = slow->next;
                node = node->next;
            }
            return node;
        }
    }
    return nullptr;
}
```

[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

```C++
// 哈希表
ListNode* getIntersectionNodeByMap(ListNode *list1, ListNode *list2) {
	map<ListNode *, bool> map;
    for (ListNode *curr = list1; curr; curr = curr->next) {
        map.insert(make_pair(curr, true));
    }
    for (ListNode *curr = list2; curr; curr = curr->next) {
        if (map.count(curr)) {
            return curr;
        }
    }
    return nullptr;
}

// 暴力枚举
ListNode *getIntersectionNodeByEnumerate(ListNode *list1, ListNode *list2) {
    for (ListNode *i = list1; i; i = i->next) {
        for (ListNode *j = list2; j; j = j->next) {
            if (i == j) {
                return j;
            }
        }
    }
    return nullptr;
}

// 截取
ListNode *getIntersectionNode(ListNode *list1, ListNode *list2) {
    size_t size1 = getListSize(list1);
    size_t size2 = getListSize(list2);

    ListNode *slow = nullptr;
    ListNode *fast = nullptr;
    size_t diff = 0;
    if (sizeA > sizeB) {
        diff = size1 - size2;
        slow = head2;
        fast = head1;
    } else {
        diff = size2 - size1;
        slow = head1;
        fast = head2;
    }

    while (diff--) {
        fast = fast->next;
    }

    while (fast) {
        if (fast == slow) {
            return slow;
        }
        fast = fast->next;
        slow = slow->next;
    }
    return nullptr;
}

// 补齐
ListNode *getIntersectionNode(ListNode *list1, ListNode *list2) {
    ListNode *p1 = list1, *p2 = list2;
    while (p1 != p2) {
        p1 = p1 == nullptr ? list2 : p1->next;
        p2 = p2 == nullptr ? list1 : p2->next;
    }
    return p1;
}
```

### 高精度运算

[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

```C++
ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
    ListNode head;
    ListNode *tail = &head;
    int carry = 0;
    while (l1 || l2) {
        int number1 = l1 ? l1->val : 0;
        int number2 = l2 ? l2->val : 0;
        int sum = number1 + number2 + carry;

        // 尾插法插入元素
        tail->next = new ListNode(sum % 10);
        tail = tail->next;

        carry = sum / 10;
        if (l1) {
            l1 = l1->next;
        }
        if (l2) {
            l2 = l2->next;
        }
    }
    if (carry > 0) {
        tail->next = new ListNode(carry);
    }
    return head.next;
}
```

## 栈与队列

### 要点

单调栈：‌单调栈是一种特殊的栈结构，其元素始终保持单调递增或递减的顺序，主要用于高效解决‌**寻找元素邻近极值**‌类问题，能将时间复杂度从O(n2)优化至O(n)。

最大/最小栈：包含max/min函数的栈，使之求栈中最大/最小值的时间复杂度为O(1)。

单调队列：单调队列常用于处理**滑动窗口或连续区间中的最值**。

### 模拟

[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

```
class MyStack {
private:
    queue<int> q;

public:
    MyStack() {
    }

    void push(int x) {
        q.push(x);
    }

    int pop() {
        queue<int> temp;
        while (q.size() > 1) {
            temp.push(q.front());
            q.pop();
        }

        int result = q.front();
        q.pop();

        while (!temp.empty()) {
            q.push(temp.front());
            temp.pop();
        }
        return result;
    }

    int top() {
        return q.back();
    }

    bool empty() {
        return q.empty();
    }
};
```

[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

```
class MyQueue {
private:
    stack<int> s;
    
public:
    MyQueue() {
    }

    void push(int x) {
        s.push(x);
    }

    int pop() {
        stack<int> temp;
        while (!s.empty()) {
            temp.push(s.top());
            s.pop();
        }

        int result = temp.top();
        temp.pop();

        while (!temp.empty()) {
            s.push(temp.top());
            temp.pop();
        }

        return result;
    }

    int peek() {
        stack<int> temp;
        while (!s.empty()) {
            temp.push(s.top());
            s.pop();
        }

        int result = temp.top();

        while (!temp.empty()) {
            s.push(temp.top());
            temp.pop();
        }

        return result;
    }

    bool empty() {
        return s.empty();
    }
};
```

### 单调栈

| 方向     | 比较方式（栈仅记录下标）       | 栈类型（从栈底到栈顶） | 用途                               |
| -------- | ------------------------------ | ---------------------- | ---------------------------------- |
| 从左往右 | `nums[stack.top()] >= nums[i]` | 单调递增栈             | 找**左边**第一个比当前**小**的元素 |
| 从左往右 | `nums[stack.top()] <= nums[i]` | 单调递减栈             | 找**左边**第一个比当前**大**的元素 |
| 从右往左 | `nums[stack.top()] >= nums[i]` | 单调递增栈             | 找**右边**第一个比当前**小**的元素 |
| 从右往左 | `nums[stack.top()] <= nums[i]` | 单调递减栈             | 找**右边**第一个比当前**大**的元素 |

[496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

```
vector<int> nextGreaterElement(vector<int> &nums1, vector<int> &nums2) {
    stack<int> stack;
    unordered_map<int, int> map;
    for (int i = nums2.size() - 1; i >= 0; i--) {
        while (!stack.empty() && nums2[stack.top()] < nums2[i]) {
            stack.pop();
        }
        map[nums2[i]] = stack.empty() ? -1 : nums2[stack.top()];
        stack.push(i);
    }

    vector<int> result(nums1.size());
    for (int i = 0; i < nums1.size(); i++) {
        result[i] = map[nums1[i]];
    }
    return result;
}
```

[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

```
vector<int> dailyTemperatures(vector<int> &temperatures) {
    vector<int> result(temperatures.size(), 0);
    stack<int> stack;
    for (int i = temperatures.size() - 1; i >= 0; i--) {
        while (!stack.empty() && temperatures[stack.top()] < temperatures[i]) {
            stack.pop();
        }
        result[i] = stack.empty() ? 0 : stack.top() - i;
        stack.push(i);
    }
    return result;
}
```

[901. 股票价格跨度](https://leetcode.cn/problems/online-stock-span/)

```
class StockSpanner {
private:
    vector<int> stock;
    stack<int> stack;

public:
    StockSpanner() {
    }

    int next(int price) {
        stock.push_back(price);

        int result = 1;
        while (!stack.empty() && stock[stack.top()] <= stock[stock.size() - 1]) {
            stack.pop();
        }
        result = stack.empty() ? stock.size() - 1 - (-1) : stock.size() - 1 - stack.top();
        stack.push(stock.size() - 1);

        return result;
    }
};
```

[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

```
int trap(vector<int> &height) {
    int result = 0;
    stack<int> stack;
    for (int i = 0; i < height.size(); i++) {
        while (!stack.empty() && height[stack.top()] <= height[i]) {
            int mid = stack.top();
            stack.pop();
            if (!stack.empty()) {
                int left = stack.top();
                result += (i - left - 1) * (min(height[left], height[i]) - height[mid]);
            }
        }
        stack.push(i);
    }
    return result;
}
```

[84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

```
int largestRectangleArea(vector<int> &heights) {
    vector<int> left(heights.size(), 0);
    stack<int> lstack;
    for (int i = 0; i < heights.size(); i++) {
        while (!lstack.empty() && heights[lstack.top()] >= heights[i]) {
            lstack.pop();
        }
        left[i] = !lstack.empty() ? lstack.top() : -1;
        lstack.push(i);
    }

    vector<int> right(heights.size(), 0);
    stack<int> rstack;
    for (int i = heights.size() - 1; i >= 0; i--) {
        while (!rstack.empty() && heights[rstack.top()] >= heights[i]) {
            rstack.pop();
        }
        right[i] = !rstack.empty() ? rstack.top() : heights.size();
        rstack.push(i);
    }

    int ans = 0;
    for (int i = 0; i < heights.size(); i++) {
        ans = max(ans, (right[i] - left[i] - 1) * heights[i]);
    }
    return ans;
}
```

[316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)

```
string removeDuplicateLetters(string s) {
    vector<int> index(26, 0);
    for (int i = 0; i < s.length(); i++) {
        index[s[i] - 'a'] = i;
    }

    vector<bool> visited(26, false);
    string stack;
    for (int i = 0; i < s.length(); i++) {
        if (!visited[s[i] - 'a']) {
            while (!stack.empty() && stack.back() >= s[i] && i < index[stack.back() - 'a']) {
                visited[stack.back() - 'a'] = false;
                stack.pop_back();
            }
            visited[s[i] - 'a'] = true;
            stack.push_back(s[i]);
        }
    }

    return stack;
}
```

### 单调队列

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

```
vector<int> maxSlidingWindow(vector<int> &nums, int k) {
    vector<int> result;
    deque<int> dq;
    for (int i = 0; i < nums.size(); i++) {
        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        dq.push_back(i);
        if (dq.front() <= i - k) {
            dq.pop_front();
        }

        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    return result;
}
```

### 最大/最小栈

[716. 最大栈](https://leetcode.cn/problems/max-stack/)

```
class MaxStack {
private:
    stack<int> s;
    stack<int> support;

public:
    MaxStack() {
    }

    void push(int x) {
        if (s.empty()) {
            support.push(x);
        } else {
            support.push(max(support.top(), x));
        }
        s.push(x);
    }

    void pop() {
        s.pop();
        support.pop();
    }

    int top() {
        return s.top();
    }

    int getMax() {
        return support.top();
    }
};
```

[155. 最小栈](https://leetcode.cn/problems/min-stack/)

```
class MinStack {
private:
    stack<int> s;
    stack<int> support;

public:
    MinStack() {
    }

    void push(int x) {
        if (s.empty()) {
            support.push(x);
        } else {
            support.push(min(support.top(), x));
        }
        s.push(x);
    }

    void pop() {
        s.pop();
        support.pop();
    }

    int top() {
        return s.top();
    }

    int getMin() {
        return support.top();
    }
};
```

### 字符串去重

[1209. 删除字符串中的所有相邻重复项 II](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/)

```
string removeDuplicates(string s, int k) {
    stack<int> counter;
    for (int i = 0; i < s.size(); i++) {
        if (i == 0 || s[i] != s[i - 1]) {
            counter.push(1);
        } else {
            if (++counter.top() == k) {
                counter.pop();
                s.erase(i - k + 1, k);
                i = i - k + 1;
            }
        }
    }
    return s;
}
```

### 括号匹配

[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

```
bool isValid(string s) {
    stack<int> stack;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '(' || s[i] == '[' || s[i] == '{') stack.push(i);
        else {
            if (stack.empty()) return false;
            if (s[i] == ')' && s[stack.top()] != '(') return false;
            if (s[i] == '}' && s[stack.top()] != '{') return false;
            if (s[i] == ']' && s[stack.top()] != '[') return false;
            stack.pop();
        }
    }
    return stack.empty();
}
```

### 表达式求值

[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

```
int evalRPN(vector<string> &tokens) {
    stack<int> stack;
    for (int i = 0; i < tokens.size(); i++) {
        string token = tokens[i];
        if (token == "+" || token == "-" || token == "*" || token == "/") {
            int right = stack.top();
            stack.pop();
            int left = stack.top();
            stack.pop();
            switch (token[0]) {
                case '+':
                    stack.push(left + right);
                    break;
                case '-':
                    stack.push(left - right);
                    break;
                case '*':
                    stack.push(left * right);
                    break;
                case '/':
                    stack.push(left / right);
                    break;
                default:
                    break;
            }
        } else {
            stack.push(stoi(token));
        }
    }
    return stack.top();
}
```

[224. 基本计算器](https://leetcode.cn/problems/basic-calculator/)

```
string strip(const string &s) {
    string result;
    for (int i = 0; i < s.length(); i++) {
        if (!isspace(s[i])) {
            result += s[i];
        }
    }
    return result;
}

string unarytobinary(const string &s) {
    string result;
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '-' || s[i] == '+') {
            if (i == 0 || s[i - 1] == '(') {
                result += "0";
            }
        }
        result += s[i];
    }
    return result;
}

int calculate(string s) {
    string expression = unarytobinary(strip(s));
    unordered_map<char, int> precedence = {
        make_pair('+', 1),
        make_pair('-', 1),
        make_pair('*', 2),
        make_pair('/', 2),
    };
    stack<int> numbers;
    stack<char> operators;
    for (int i = 0; i < expression.size(); i++) {
        if (!isspace(expression[i])) {
            if (isdigit(expression[i])) {
                int number = 0;
                while (i < expression.size() && isdigit(expression[i])) {
                    number = number * 10 + (expression[i++] - '0');
                }
                numbers.push(number);
                i--;
            } else if (expression[i] == '(') {
                operators.push(expression[i]);
            } else if (expression[i] == ')') {
                while (!operators.empty() && operators.top() != '(') {
                    int number2 = numbers.top();
                    numbers.pop();
                    int number1 = numbers.top();
                    numbers.pop();
                    char operate = operators.top();
                    operators.pop();
                    if (operate == '+') {
                        numbers.push(number1 + number2);
                    } else if (operate == '-') {
                        numbers.push(number1 - number2);
                    } else if (operate == '*') {
                        numbers.push(number1 * number2);
                    } else if (operate == '/') {
                        numbers.push(number1 / number2);
                    }
                }
                operators.pop();
            } else {
                while (!operators.empty() && precedence[expression[i]] <= precedence[operators.top()]) {
                    int number2 = numbers.top();
                    numbers.pop();
                    int number1 = numbers.top();
                    numbers.pop();
                    char operate = operators.top();
                    operators.pop();
                    if (operate == '+') {
                        numbers.push(number1 + number2);
                    } else if (operate == '-') {
                        numbers.push(number1 - number2);
                    } else if (operate == '*') {
                        numbers.push(number1 * number2);
                    } else if (operate == '/') {
                        numbers.push(number1 / number2);
                    }
                }
                operators.push(expression[i]);
            }
        }
    }
    while (!operators.empty()) {
        int number2 = numbers.top();
        numbers.pop();
        int number1 = numbers.top();
        numbers.pop();
        char operate = operators.top();
        operators.pop();
        if (operate == '+') {
            numbers.push(number1 + number2);
        } else if (operate == '-') {
            numbers.push(number1 - number2);
        } else if (operate == '*') {
            numbers.push(number1 * number2);
        } else if (operate == '/') {
            numbers.push(number1 / number2);
        }
    }
    return numbers.top();
}
```

### 优先队列

[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

```
vector<int> topKFrequent(vector<int> &nums, int k) {
    unordered_map<int, int> map;
    for (int i = 0; i < nums.size(); i++) {
        map[nums[i]]++;
    }

    vector<int> result(k);
    auto compare = [](auto &left, auto &right) { return left.second < right.second; };
    priority_queue<pair<int, int>, vector<pair<int, int> >, decltype(compare)>
            pq(map.begin(), map.end(), compare);

    for (int i = 0; i < k; i++) {
        result[i] = pq.top().first;
        pq.pop();
    }
    return result;
}
```

[692. 前K个高频单词](https://leetcode.cn/problems/top-k-frequent-words/)

```
vector<string> topKFrequent(vector<string> &words, int k) {
    unordered_map<string, int> map;
    for (int i = 0; i < words.size(); i++) {
        map[words[i]]++;
    }

    vector<string> result(k);
    auto compare = [](auto &left, auto &right) {
        if (left.second != right.second) {
            return left.second < right.second;
        } else {
            return left.first > right.first;
        }
    };

    priority_queue<pair<string, int>, vector<pair<string, int> >, decltype(compare)> pq(
        map.begin(), map.end(), compare);
    for (int i = 0; i < k; i++) {
        result[i] = pq.top().first;
        pq.pop();
    }
    return result;
}
```

## 字符串

### 字符

```
isupper(c);	// 大写字母
islower(c);	// 小写字母
isalpha(c);	// 字母
isdigit(c);	// 数字
isalnum(c);	// 字母和数字
isspace(c);	// 空格
```

### 字符串与数字间转换

```
stoi(s);	// 字符串转数字
itos(n);	// 数字转字符串
```

### 分割字符串

[434. 字符串中的单词数](https://leetcode.cn/problems/number-of-segments-in-a-string/)

```
int countSegments(string s) {
    int count = 0;
    int begin = 0;
    int end = s.find(' ', begin);
    while (end != string::npos) {
        if (begin != end) {
            count++;
        }
        begin = end + 1;
        end = s.find(' ', begin);
    }
    return begin != s.length() ? count + 1 : count;
}
```

### 反转字符串

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

```
void reverseString(vector<char> &s) {
    int left = 0;
    int right = s.size() - 1;
    while (left < right) {
        swap(s[left], s[right]);
        left++;
        right--;
    }
}
```

### 回文串

[125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)

```
bool isPalindrome(string s) {
    string str = "";
    for (const auto &c: s) {
        if (isalpha(c) || isdigit(c)) {
            str += tolower(c);
        }
    }

    int left = 0;
    int right = str.length() - 1;
    while (left < right && str[left] == str[right]) {
        left++;
        right--;
    }
    return left >= right;
}
```

[214. 最短回文串](https://leetcode.cn/problems/shortest-palindrome/)

```
vector<int> getNext(const string &s) {
    vector<int> next(s.size(), 0);
    next[0] = -1;
    int i = 0;
    int j = -1;
    while (i < s.length() - 1) {
        if (j == -1 || s[i] == s[j]) {
            next[++i] = ++j;
        } else {
            j = next[j];
        }
    }
    return next;
}

string shortestPalindrome(string s) {
    string rs = s;
    reverse(rs.begin(), rs.end());
    string str = s + "#" + rs;
    vector<int> next = getNext(str);
    int length = next[str.length() - 1];
    return rs.substr(0, rs.length() - length - 1) + s;
}
```

### 字符串匹配

[28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

```
// 暴力匹配
int strStr(string haystack, string needle) {
    for (int i = 0; i < haystack.length(); i++) {
        int p = i;
        int q = 0;
        while (p < haystack.length() && q < needle.length() && haystack[p] == needle[q]) {
            p++;
            q++;
        }
        if (q == needle.length()) {
            return i;
        }
    }
    return -1;
}

// KMP算法
vector<int> getNext(const string &s) {
    vector<int> next(s.size(), 0);
    next[0] = -1;
    int i = 0;
    int j = -1;
    while (i < s.length() - 1) {
        if (j == -1 || s[i] == s[j]) {
            next[++i] = ++j;
        } else {
            j = next[j];
        }
    }
    return next;
}

int strStr(string haystack, string needle) {
    vector<int> next = getNext(needle);

    int m = haystack.length();
    int n = needle.length();

    int i = 0;
    int j = 0;
    while (i < m && j < n) {
        if (j == -1 || haystack[i] == needle[j]) {
            i++;
            j++;
        } else {
            j = next[j];
        }
    }
    return j == needle.length() ? i - j : -1;
}

// Sunday算法
unordered_map<char, int> getOffset(string s) {
    unordered_map<char, int> offset;
    for (int i = 0; i < s.size(); i++) {
        offset[s[i]] = s.length() - i;
    }
    return offset;
}

int strStr(string haystack, string needle) {
    unordered_map<char, int> offset = getOffset(needle);

    int m = haystack.length();
    int n = needle.length();

    for (int i = 0; i <= m - n;) {
        if (haystack.substr(i, n) == needle) {
            return i;
        }

        if (i < m - n) {
            i += offset.count(haystack[i + n]) ? offset[haystack[i + n]] : n + 1;
        } else {
            break;
        }
    }
    return -1;
}
```

### 子序列

[392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

```
bool isSubsequence(string s, string t) {
    int n = s.length(), m = t.length();
    int i = 0, j = 0;
    while (i < n && j < m) {
        if (s[i] == t[j]) {
            i++;
        }
        j++;
    }
    return i == n;
}
```

[521. 最长特殊序列 Ⅰ](https://leetcode.cn/problems/longest-uncommon-subsequence-i/)

```
int findLUSlength(string a, string b) {
    return a != b ? max(a.length(), b.length()) : -1;
}
```

[522. 最长特殊序列 II](https://leetcode.cn/problems/longest-uncommon-subsequence-ii/)

```
bool isSubsequence(string s, string t) {
    int n = s.length(), m = t.length();
    int i = 0, j = 0;
    while (i < n && j < m) {
        if (s[i] == t[j]) {
            i++;
        }
        j++;
    }
    return i == n;
}

int findLUSlength(vector<string> &strs) {
    int result = -1;
    for (int i = 0; i < strs.size(); i++) {
        bool subsequence = true;
        for (int j = 0; j < strs.size(); j++) {
            if (j != i && isSubsequence(strs[i], strs[j])) {
                subsequence = false;
                break;
            }
        }
        if (subsequence) {
            result = max(result, static_cast<int>(strs[i].length()));
        }
    }
    return result;
}
```

### 最长公共前缀

[14. 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)

```
// 横向比较
string longestCommonPrefix(vector<string> &strs) {
    string prefix = strs[0];
    int count = strs.size();
    for (int i = 1; i < count; i++) {
        prefix = longestCommonPrefix(prefix, strs[i]);
        if (!prefix.size()) {
            break;
        }
    }
    return prefix;
}

string longestCommonPrefix(const string &str1, const string &str2) {
    int length = min(str1.size(), str2.size());
    int index = 0;
    while (index < length && str1[index] == str2[index]) {
        index++;
    }
    return str1.substr(0, index);
}

// 纵向比较
string longestCommonPrefix(vector<string>& strs) {
    int length = strs[0].size();
    int count = strs.size();
    for (int i = 0; i < length; ++i) {
        char c = strs[0][i];
        for (int j = 1; j < count; j++) {
            if (i == strs[j].size() || strs[j][i] != c) {
                return strs[0].substr(0, i);
            }
        }
    }
    return strs[0];
}
```

### 重复子串

[459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

```
bool repeatedSubstringPattern(string s) {
	// 判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。
    string t = s + s;
    t.erase(t.begin());
    t.erase(t.end() - 1);
    return t.find(s) != std::string::npos;
}
```

### 高精度运算

[415. 字符串相加](https://leetcode.cn/problems/add-strings/)

```
void reverse(string &s) {
    int left = 0;
    int right = s.length() - 1;
    while (left < right) {
        swap(s[left], s[right]);
        left++;
        right--;
    }
}

string addStrings(string num1, string num2) {
    reverse(num1);
    reverse(num2);

    string result;
    int i = 0;
    int carry = 0;
    while (i < num1.length() || i < num2.length()) {
        int n1 = i < num1.length() ? num1[i] - '0' : 0;
        int n2 = i < num2.length() ? num2[i] - '0' : 0;
        int sum = (n1 + n2 + carry) % 10;
        carry = (n1 + n2 + carry) / 10;
        result.push_back(sum + '0');
        i++;
    }

    while (i < num1.length()) {
        int n1 = num1[i] - '0';
        int sum = (n1 + carry) % 10;
        carry = (n1 + carry) / 10;
        result.push_back(sum + '0');
        i++;
    }

    while (i < num2.length()) {
        int n2 = num2[i] - '0';
        int sum = (n2 + carry) % 10;
        carry = (n2 + carry) / 10;
        result.push_back(sum + '0');
        i++;
    }

    if (carry) {
        result.push_back(carry + '0');
    }

    reverse(result);
    return result;
}
```

## 树与二叉树

### 先序遍历二叉树

先序遍历（[144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)）

```
vector<int> result;

void travel(TreeNode* root) {
    if (root) {
        result.push_back(root->val);
        travel(root->left);
        travel(root->right);
    }
}

// 递归版本
vector<int> preorderTraversal(TreeNode *root) {
    travel(root);
    return result;
}

// 非递归版本
vector<int> preorderTraversal(TreeNode *root) {
    vector<int> result;
    if (root) {
        stack<TreeNode *> stack;
        stack.push(root);
        while (!stack.empty()) {
            TreeNode *node = stack.top();
            stack.pop();
            
            result.push_back(node->val);
            
            if (node->right) {
                stack.push(node->right);
            }
            
            if (node->left) {
                stack.push(node->left);
            }
        }
    }
    return result;
}
```

### 中序遍历二叉树

中序遍历（[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)）

```
vector<int> result;

void travel(TreeNode* root) {
    if (root) {
        travel(root->left);
        result.push_back(root->val);
        travel(root->right);
    }
}

// 递归版本
vector<int> inorderTraversal(TreeNode *root) {
    travel(root);
    return result;
}

// 非递归版本
vector<int> inorderTraversal(TreeNode *root) {
    vector<int> result;
    TreeNode *node = root;
    stack<TreeNode *> stack;
    while (node || !stack.empty()) {
        while (node) {
            stack.push(node);
            node = node->left;
        }
        
        node = stack.top();
        stack.pop();
        
        result.push_back(node->val);
        
        node = node->right;
    }
    return result;
}
```

### 后序遍历二叉树

后序遍历（[145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)）

```
vector<int> result;

void travel(TreeNode* root) {
    if (root) {
        travel(root->left);
        travel(root->right);
        result.push_back(root->val);
    }
}

// 递归版本
vector<int> postorderTraversal(TreeNode *root) {
    travel(root);
    return result;
}

// 非递归版本
vector<int> postorderTraversal(TreeNode *root) {
    vector<int> result;
    TreeNode *node = root;
    TreeNode *previous = nullptr;
    stack<TreeNode *> stack;
    while (node || !stack.empty()) {
        while (node) {
            stack.push(node);
            node = node->left;
        }

        node = stack.top();
        stack.pop();

        if (node->right == nullptr || node->right == previous) {
            result.push_back(node->val);
            previous = node;
            node = nullptr;
        } else {
            stack.push(node);
            node = node->right;
        }
    }
    return result;
}
```

### 层序遍历二叉树

层序遍历（[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)）

```
// 递归版本
void dfs(TreeNode *root, int depth, vector<vector<int> > &result) {
    if (root) {
        if (depth == result.size()) {
            result.emplace_back(vector<int>());
        }
        result[depth].push_back(root->val);
        dfs(root->left, depth + 1, result);
        dfs(root->right, depth + 1, result);
    }
}

vector<vector<int> > levelOrder(TreeNode *root) {
    vector<vector<int> > result;
    dfs(root, 0, result);
    return result;
}

// 非递归版本
vector<vector<int> > levelOrder(TreeNode *root) {
    vector<vector<int> > result;
    if (root) {
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            vector<int> level;
            int size = q.size();
            for (int i = 0; i < size; i++) {
                TreeNode *node = q.front();
                q.pop();
                level.push_back(node->val);
                if (node->left) {
                    q.push(node->left);
                }
                if (node->right) {
                    q.push(node->right);
                }
            }
            result.push_back(level);
        }
    }
    return result;
}
```

[429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

```
vector<vector<int> > levelOrder(Node *root) {
    vector<vector<int> > result;
    if (root) {
        queue<Node *> q;
        q.push(root);
        while (!q.empty()) {
            vector<int> level;
            int size = q.size();
            for (int i = 0; i < size; i++) {
                Node *node = q.front();
                q.pop();
                level.emplace_back(node->val);
                for (const auto &c: node->children) {
                    q.push(c);
                }
            }
            result.push_back(level);
        }
    }
    return result;
}
```

### 二叉树的路径

[257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

```
void dfs(TreeNode *root, string path, vector<string> &result) {
    if (root) {
        path += to_string(root->val);
        if (!root->left && !root->right) {
            result.push_back(path);
        } else {
            path += "->";
            dfs(root->left, path, result);
            dfs(root->right, path, result);
        }
    }
}

vector<string> binaryTreePaths(TreeNode *root) {
    vector<string> result;
    if (root) {
        dfs(root, "", result);
    }
    return result;
}
```

### 先序序列与中序序列构造二叉树

[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```
TreeNode *merge(TreeNode *root, TreeNode *left, TreeNode *right) {
    if (root) {
        root->left = left;
        root->right = right;
    }
    return root;
}

TreeNode *buildTree(unordered_map<int, int> &map, vector<int> &preorder, int l1, int r1, vector<int> &inorder,
                    int l2, int r2) {
    if (l2 > r2) {
        return nullptr;
    }

    int mid = map[preorder[l1]];
    int size = mid - l2;
    return merge(new TreeNode(inorder[mid]),
                 buildTree(map, preorder, l1 + 1, l1 + size, inorder, l2, mid - 1),
                 buildTree(map, preorder, l1 + size + 1, r1, inorder, mid + 1, r2)
    );
}

TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {
    unordered_map<int, int> map;
    for (int i = 0; i < inorder.size(); i++) {
        map[inorder[i]] = i;
    }
    return buildTree(map, preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);
}
```

### 中序序列与后序序列构造二叉树

[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```
TreeNode *merge(TreeNode *root, TreeNode *left, TreeNode *right) {
    if (root) {
        root->left = left;
        root->right = right;
    }
    return root;
}

TreeNode *buildTree(unordered_map<int, int> &map, vector<int> &postorder, int l1, int r1, vector<int> &inorder,
                    int l2, int r2) {
    if (l2 > r2) {
        return nullptr;
    }

    int mid = map[postorder[r1]];
    int size = mid - l2;
    return merge(new TreeNode(inorder[mid]),
                 buildTree(map, postorder, l1, l1 + size - 1, inorder, l2, mid - 1),
                 buildTree(map, postorder, l1 + size, r1 - 1, inorder, mid + 1, r2)
    );
}

TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {
    unordered_map<int, int> map;
    for (int i = 0; i < inorder.size(); i++) {
        map[inorder[i]] = i;
    }
    return buildTree(map, postorder, 0, postorder.size() - 1, inorder, 0, inorder.size() - 1);
}
```

### 前序序列与后序序列构造二叉树

[889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

```
TreeNode *merge(TreeNode *root, TreeNode *left, TreeNode *right) {
    if (root) {
        root->left = left;
        root->right = right;
    }
    return root;
}

TreeNode *buildTree(unordered_map<int, int> &map, vector<int> &preorder, int l1, int r1, vector<int> &postorder,
                    int l2, int r2) {
    if (l1 > r1) {
        return nullptr;
    }

    if (l1 == r1) {
        return new TreeNode(preorder[l1]);
    }

    int left = map[preorder[l1 + 1]];
    int size = left - l2 + 1;
    return merge(new TreeNode(preorder[l1]),
                 buildTree(map, preorder, l1 + 1, l1 + size, postorder, l2, left),
                 buildTree(map, preorder, l1 + size + 1, r1, postorder, left + 1, r2 - 1)
    );
}

TreeNode *constructFromPrePost(vector<int> &preorder, vector<int> &postorder) {
    unordered_map<int, int> map;
    for (int i = 1; i < postorder.size(); i++) {
        map[postorder[i]] = i;
    }
    return buildTree(map, preorder, 0, preorder.size() - 1, postorder, 0, postorder.size() - 1);
}
```

### 二叉树的最近公共祖先

[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

```
TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {
    if (!root || root == p || root == q) {
        return root;
    }

    TreeNode *left = lowestCommonAncestor(root->left, p, q);
    TreeNode *right = lowestCommonAncestor(root->right, p, q);
    if (left && right) {
        return root;
    }
    return left ? left : right;
}
```

[235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```
TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {
    if (root->val < p->val && root->val < q->val) {
        return lowestCommonAncestor(root->right, p, q);
    } else if (root->val > p->val && root->val > q->val) {
        return lowestCommonAncestor(root->left, p, q);
    } else {
        return root;
    }
}
```

### 二叉搜索树

[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

```
bool isValidBST(TreeNode *root, long left, long right) {
    if (root) {
        return left < root->val && root->val < right && isValidBST(root->left, left, root->val) && isValidBST(
                   root->right, root->val, right);
    } else {
        return true;
    }
}

bool isValidBST(TreeNode *root) {
    return isValidBST(root, LONG_MIN, LONG_MAX);
}
```

[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

```
TreeNode *merge(TreeNode *root, TreeNode *left, TreeNode *right) {
    if (root) {
        root->left = left;
        root->right = right;
    }
    return root;
}

TreeNode *sortedArrayToBST(vector<int> &nums, int left, int right) {
    if (left > right) {
        return nullptr;
    }
    int mid = left + (right - left) / 2;
    return merge(new TreeNode(nums[mid]), sortedArrayToBST(nums, left, mid - 1),
                 sortedArrayToBST(nums, mid + 1, right));
}

TreeNode *sortedArrayToBST(vector<int> &nums) {
    return sortedArrayToBST(nums, 0, nums.size() - 1);
}
```

[109. 有序链表转换二叉搜索树](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)

```
TreeNode *merge(TreeNode *root, TreeNode *left, TreeNode *right) {
    if (root) {
        root->left = left;
        root->right = right;
    }
    return root;
}

ListNode *middle(ListNode *head, ListNode *tail) {
    ListNode *slow = head;
    ListNode *fast = head;
    while (fast != tail && fast->next != tail) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}

TreeNode *sortedListToBST(ListNode *head, ListNode *tail) {
    if (head == tail) {
        return nullptr;
    }

    ListNode *mid = middle(head, tail);
    return merge(new TreeNode(mid->val), sortedListToBST(head, mid),
                 sortedListToBST(mid->next, tail));
}

TreeNode *sortedListToBST(ListNode *head) {
    return sortedListToBST(head, nullptr);
}
```

[1382. 将二叉搜索树变平衡](https://leetcode.cn/problems/balance-a-binary-search-tree/)

```
void inorder(TreeNode *root, vector<TreeNode *> &nodes) {
    if (root) {
        inorder(root->left, nodes);
        nodes.push_back(root);
        inorder(root->right, nodes);
    }
}

TreeNode *merge(TreeNode *root, TreeNode *left, TreeNode *right) {
    if (root) {
        root->left = left;
        root->right = right;
    }
    return root;
}

TreeNode *balanceBST(vector<TreeNode *> &nodes, int left, int right) {
    if (left > right) {
        return nullptr;
    }

    int mid = left + (right - left) / 2;
    return merge(new TreeNode(nodes[mid]->val), balanceBST(nodes, left, mid - 1),
                 balanceBST(nodes, mid + 1, right));
}

TreeNode *balanceBST(TreeNode *root) {
    vector<TreeNode *> nodes;
    inorder(root, nodes);
    return balanceBST(nodes, 0, nodes.size() - 1);
}
```

### 平衡二叉树

[110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

```
int depth(TreeNode *root) {
    return root ? max(depth(root->left), depth(root->right)) + 1 : 0;
}

bool isBalanced(TreeNode *root) {
    return root ? abs(depth(root->left) - depth(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right) : true;
}
```

## 图

### 深度优先搜索/广度优先搜索

#### 算法模板

```
void dfs(vector<vector<int> > &graph, int node, vector<bool> &visited) {
    visited[node] = true;

    // 处理当前节点 node
    for (int neighbor: graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor, graph, visited);
        }
    }
}

void bfs(vector<vector<int> > &graph, int start, vector<bool> &visited) {
    visited[start] = true;
    queue<int> q;
    q.push(start);
    while (!q.empty()) {
        int node = q.front();
        q.pop();

        // 处理当前节点 node
        for (int neighbor: graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}

vector<bool> visited(n, false);
for (int i = 0; i < graph.size(); i++) {
    if (!visited[i]) {
        dfs(graph, i, visited);
        // bfs(graph, i, visited);
    }
}
```

#### 求解问题

[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

```
void bfs(vector<vector<char> > &grid, int i, int j, vector<vector<bool> > &visited) {
	visited[i][j] = true;
    queue<pair<int, int> > q;
    q.push(make_pair(i, j));
    while (!q.empty()) {
        int x = q.front().first;
        int y = q.front().second;
        q.pop();
        vector<pair<int, int> > directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (const auto &direction: directions) {
            int dx = x + direction.first;
            int dy = y + direction.second;
            if (dx >= 0 && dx < grid.size() && dy >= 0 && dy < grid[dx].size() && !visited[dx][dy] && grid[dx][
                    dy] == '1') {
                visited[x][y] = true;
                q.push(make_pair(dx, dy));
            }
        }
    }
}

void dfs(vector<vector<char> > &grid, int i, int j, vector<vector<bool> > &visited) {
    visited[i][j] = true;
    vector<pair<int, int> > directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    for (const auto &direction: directions) {
        int x = i + direction.first;
        int y = j + direction.second;
        if (x >= 0 && x < grid.size() && y >= 0 && y < grid[x].size() && !visited[x][y] && grid[x][y] == '1') {
            dfs(grid, x, y, visited);
        }
    }
}

int numIslands(vector<vector<char> > &grid) {
    vector<vector<bool> > visited(grid.size(), vector<bool>(grid[0].size(), false));
    int result = 0;
    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[0].size(); j++) {
            if (!visited[i][j] && grid[i][j] == '1') {
                dfs(grid, i, j, visited);
                result++;
            }
        }
    }
    return result;
}
```

[133. 克隆图](https://leetcode.cn/problems/clone-graph/)

```
Node *bfs(Node *node, unordered_map<Node *, Node *> &map) {
    map.insert({node, new Node(node->val)});
    queue<Node *> q;
    q.push(node);
    while (!q.empty()) {
        Node *n = q.front();
        q.pop();
        for (const auto &neighbor: n->neighbors) {
            if (!map.contains(neighbor)) {
                map[neighbor] = new Node(neighbor->val);
                q.push(neighbor);
            }
            map[n]->neighbors.emplace_back(map[neighbor]);
        }
    }
    return map.at(node);
}

Node *dfs(Node *node, unordered_map<Node *, Node *> &map) {
    Node *n = new Node(node->val);
    map.insert({node, n});
    for (const auto &neighbor: node->neighbors) {
        if (map.contains(neighbor)) {
            n->neighbors.emplace_back(map.at(neighbor));
        } else {
            n->neighbors.emplace_back(dfs(neighbor, map));
        }
    }
    return n;
}

Node *cloneGraph(Node *node) {
    if (node) {
        unordered_map<Node *, Node *> map;
        return dfs(node, map);
    }
    return nullptr;
}
```

[1743. 从相邻元素对还原数组](https://leetcode.cn/problems/restore-the-array-from-adjacent-pairs/)

```
void bfs(unordered_map<int, unordered_set<int> > &graph, int node,
         unordered_map<int, bool> &visited, vector<int> &result) {
    visited[node] = true;
    queue<int> q;
    q.push(node);
    while (!q.empty()) {
        int n = q.front();
        q.pop();
        result.emplace_back(n);
        for (const auto &neighbor: graph[n]) {
            if (!visited[neighbor]) {
            	visited[n] = true;
                q.push(neighbor);
            }
        }
    }
}

void dfs(unordered_map<int, unordered_set<int> > &graph, int node,
         unordered_map<int, bool> &visited, vector<int> &result) {
    visited[node] = true;
    result.emplace_back(node);
    for (int neighbor: graph[node]) {
        if (!visited[neighbor]) {
            dfs(graph, neighbor, visited, result);
        }
    }
}

vector<int> restoreArray(vector<vector<int> > &adjacentPairs) {
    unordered_map<int, unordered_set<int> > graph;
    for (int i = 0; i < adjacentPairs.size(); i++) {
        graph[adjacentPairs[i][0]].insert(adjacentPairs[i][1]);
        graph[adjacentPairs[i][1]].insert(adjacentPairs[i][0]);
    }

    int start = 0;
    for (pair<int, unordered_set<int> > node: graph) {
        if (node.second.size() == 1) {
            start = node.first;
            break;
        }
    }

    vector<int> result;
    unordered_map<int, bool> visited;
    dfs(graph, start, visited, result);
    return result;
}
```

[127. 单词接龙](https://leetcode.cn/problems/word-ladder/)

```
int bfs(unordered_map<string, unordered_set<string> > &graph, string &node, string &endWord,
        unordered_map<string, bool> &visited) {
    int length = 1;
    visited[node] = true;
    queue<string> q;
    q.push(node);
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            string s = q.front();
            q.pop();
            if (s == endWord) {
                return length;
            }
            for (const auto &neighbor: graph[s]) {
                if (!visited[neighbor]) {
                	visited[s] = true;
                    q.push(neighbor);
                }
            }
        }
        length++;
    }
    return 0;
}

int ladderLength(string beginWord, string endWord, vector<string> &wordList) {
    if (find(wordList.begin(), wordList.end(), endWord) == wordList.end()) {
        return 0;
    }

    auto compare = [](const string &a, const string &b) {
        if (a.length() == b.length()) {
            size_t count = 0;
            int i = 0;
            int j = 0;
            while (i < a.length() && j < b.length()) {
                if (a[i] != b[j]) {
                    count++;
                }
                i++;
                j++;
            }
            return count;
        } else {
            return a.length() > b.length() ? a.length() - b.length() : b.length() - a.length();
        }
    };

    unordered_map<string, unordered_set<string> > graph;
    for (int i = 0; i < wordList.size(); i++) {
        if (compare(beginWord, wordList[i]) == 1) {
            graph[beginWord].insert(wordList[i]);
        }
    }
    for (int i = 0; i < wordList.size(); i++) {
        for (int j = i + 1; j < wordList.size(); j++) {
            if (compare(wordList[i], wordList[j]) == 1) {
                graph[wordList[i]].insert(wordList[j]);
                graph[wordList[j]].insert(wordList[i]);
            }
        }
    }
    for (int i = 0; i < wordList.size(); i++) {
        if (compare(wordList[i], endWord) == 1) {
            graph[wordList[i]].insert(endWord);
        }
    }

    unordered_map<string, bool> visited;
    return bfs(graph, beginWord, endWord, visited);
}
```

[417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

```
void dfs(vector<vector<int> > &heights, int i, int j, vector<vector<bool> > &visited) {
    vector<pair<int, int> > directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    for (const auto &direction: directions) {
        int x = i + direction.first;
        int y = j + direction.second;
        if (x >= 0 && x < heights.size() && y >= 0 && y < heights[x].size() && !visited[x][y] && heights[i][j] <=
            heights[x][y]) {
            dfs(heights, x, y, visited);
        }
    }
}

void bfs(vector<vector<int> > &heights, int i, int j, vector<vector<bool> > &visited) {
    vector<pair<int, int> > directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    visited[i][j] = true;
    queue<pair<int, int> > q;
    q.push(make_pair(i, j));
    while (!q.empty()) {
        int x = q.front().first;
        int y = q.front().second;
        q.pop();
        for (const auto &direction: directions) {
            int dx = x + direction.first;
            int dy = y + direction.second;
            if (dx >= 0 && dx < heights.size() && dy >= 0 && dy < heights[dx].size() && !visited[dx][dy] && heights[
                    x][y] <=
                heights[dx][dy]) {
                visited[dx][dy] = true;
                q.push(make_pair(dx, dy));
            }
        }
    }
}

vector<vector<int> > pacificAtlantic(vector<vector<int> > &heights) {
    vector<vector<bool> > pacific(heights.size(), vector<bool>(heights[0].size(), false));
    for (int i = 0; i < heights.size(); i++) {
        bfs(heights, i, 0, pacific);
    }
    for (int j = 0; j < heights[0].size(); j++) {
        bfs(heights, 0, j, pacific);
    }

    vector<vector<bool> > atlantic(heights.size(), vector<bool>(heights[0].size(), false));
    for (int i = 0; i < heights.size(); i++) {
        bfs(heights, i, heights[0].size() - 1, atlantic);
    }
    for (int j = 0; j < heights[0].size(); j++) {
        bfs(heights, heights.size() - 1, j, atlantic);
    }
    vector<vector<int> > result;
    for (int i = 0; i < heights.size(); i++) {
        for (int j = 0; j < heights[i].size(); j++) {
            if (pacific[i][j] && atlantic[i][j]) {
                result.push_back({i, j});
            }
        }
    }
    return result;
}
```

### 拓扑排序（深度优先搜索+逆后序/广度优先搜索）

[207. 课程表](https://leetcode.cn/problems/course-schedule/)

```
// DFS算法
bool dfs(vector<vector<int> > &graph, int course, vector<int> &visited) {
    // 是否有环
    if (visited[course] == 1) {
        return true;
    }

    // 已访问
    if (visited[course] == 2) {
        return false;
    }

    // 标记为正在访问
    visited[course] = 1;
    for (int i = 0; i < graph[course].size(); i++) {
        if (dfs(graph, graph[course][i], visited)) {
            return true;
        }
    }

    // 后序添加
    visited[course] = 2;
    return false;
}

bool canFinish(int numCourses, vector<vector<int> > &prerequisites) {
    vector<vector<int> > graph(numCourses);
    for (int i = 0; i < prerequisites.size(); i++) {
        graph[prerequisites[i][1]].emplace_back(prerequisites[i][0]);
    }

    vector<int> visited(numCourses);
    for (int i = 0; i < numCourses; i++) {
        if (!visited[i]) {
            if (dfs(graph, i, visited)) {
                return false;
            }
        }
    }
    return true;
}

// BFS算法
bool bfs(vector<vector<int> > &graph) {
    vector<int> indegree(graph.size(), 0);
    for (int i = 0; i < graph.size(); i++) {
        for (int j = 0; j < graph[i].size(); j++) {
            indegree[graph[i][j]]++;
        }
    }

    queue<int> q;
    for (int i = 0; i < indegree.size(); i++) {
        if (!indegree[i]) {
            q.push(i);
        }
    }

    int count = 0;
    while (!q.empty()) {
        int node = q.front();
        q.pop();
        count++;
        for (int i = 0; i < graph[node].size(); i++) {
            indegree[graph[node][i]]--;
            if (!indegree[graph[node][i]]) {
                q.push(graph[node][i]);
            }
        }
    }
    return count != graph.size();
}

bool canFinish(int numCourses, vector<vector<int> > &prerequisites) {
    vector<vector<int> > graph(numCourses);
    for (int i = 0; i < prerequisites.size(); i++) {
        graph[prerequisites[i][1]].emplace_back(prerequisites[i][0]);
    }
    return !bfs(graph);
}
```

[210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

```
// DFS算法
bool dfs(vector<vector<int> > &graph, int course, vector<int> &visited, vector<int> &result) {
    // 是否有环
    if (visited[course] == 1) {
        return true;
    }

    // 已访问
    if (visited[course] == 2) {
        return false;
    }

    // 标记为正在访问
    visited[course] = 1;
    for (int i = 0; i < graph[course].size(); i++) {
        if (dfs(graph, graph[course][i], visited, result)) {
            return true;
        }
    }

    // 后序添加
    visited[course] = 2;
    result.emplace_back(course);
    return false;
}

vector<int> findOrder(int numCourses, vector<vector<int> > &prerequisites) {
    vector<vector<int> > graph(numCourses);
    for (int i = 0; i < prerequisites.size(); i++) {
        graph[prerequisites[i][1]].emplace_back(prerequisites[i][0]);
    }

    vector<int> result;
    vector<int> visited(numCourses);
    for (int i = 0; i < numCourses; i++) {
        if (!visited[i]) {
            if (dfs(graph, i, visited, result)) {
                return {};
            }
        }
    }
    reverse(result.begin(), result.end());
    return result;
}

// BFS算法
void bfs(vector<vector<int> > &graph, vector<int> &result) {
    vector<int> indegree(graph.size(), 0);
    for (int i = 0; i < graph.size(); i++) {
        for (int j = 0; j < graph[i].size(); j++) {
            indegree[graph[i][j]]++;
        }
    }

    queue<int> q;
    for (int i = 0; i < indegree.size(); i++) {
        if (!indegree[i]) {
            q.push(i);
        }
    }

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        result.emplace_back(node);
        for (int i = 0; i < graph[node].size(); i++) {
            indegree[graph[node][i]]--;
            if (!indegree[graph[node][i]]) {
                q.push(graph[node][i]);
            }
        }
    }

    result = result.size() == graph.size() ? result : vector<int>{};
}

vector<int> findOrder(int numCourses, vector<vector<int> > &prerequisites) {
    vector<vector<int> > graph(numCourses);
    for (int i = 0; i < prerequisites.size(); i++) {
        graph[prerequisites[i][1]].emplace_back(prerequisites[i][0]);
    }

    vector<int> result;
    bfs(graph, result);
    return result;
}
```

### 最短路径

#### 单源最短路径（边权同为1/边权同为一个正数）

[1091. 二进制矩阵中的最短路径](https://leetcode.cn/problems/shortest-path-in-binary-matrix/)

```
int bfs(vector<vector<int> > &grid) {
    if (grid.size() == 1 && grid[0].size() == 1 && grid[0][0] == 0) {
        return 1;
    }

    vector<pair<int, int> > directions = {
                    {1, 1}, {1, 0}, {1, -1}, {0, 1}, {0, -1}, {-1, 1}, {-1, 0}, {-1, -1}
                };
    vector<vector<bool> > visited(grid.size(), vector<bool>(grid[0].size(), false));
    int length = 1;
    queue<pair<int, int> > q;
    q.push(make_pair(0, 0));
    visited[0][0] = true;
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            int x = q.front().first;
            int y = q.front().second;
            q.pop();
            for (const auto &direction: directions) {
                int dx = x + direction[0];
                int dy = y + direction[1];
                if (dx >= 0 && dx < grid.size() && dy >= 0 && dy < grid[dx].size() && !visited[dx][dy] && grid[dx][
                        dy] == 0) {
                    if (dx == grid.size() - 1 && dy == grid[dx].size() - 1) {
                        return length + 1;
                    }
                    q.push(make_pair(dx, dy));
                    visited[dx][dy] = true;
                }
            }
        }
        length++;
    }
    return -1;
}

int shortestPathBinaryMatrix(vector<vector<int> > &grid) {
    if (grid[0][0] == 1) {
        return -1;
    }

    return bfs(grid);
}
```

#### 单源最短路径（Dijkstra算法，边权非负）

[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

```
vector<int> dijkstra(vector<vector<pair<int, int> > > &graph, int start) {
    vector<int> distance(graph.size(), INT_MAX);
    distance[start] = 0;
    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<> > pq;
    pq.emplace(0, start);
    while (!pq.empty()) {
        int weight = pq.top().first;
        int u = pq.top().second;
        pq.pop();
        if (weight <= distance[u]) {
            for (const auto &edge: graph[u]) {
                if (distance[edge.first] > distance[u] + edge.second) {
                    distance[edge.first] = distance[u] + edge.second;
                    pq.emplace(distance[edge.first], edge.first);
                }
            }
        }
    }

    return distance;
}

vector<vector<int> > floyd(vector<vector<int> > &graph) {
    vector<vector<int> > distance = graph;
    for (int k = 0; k < distance.size(); k++) {
        for (int i = 0; i < distance.size(); i++) {
            for (int j = 0; j < distance.size(); j++) {
                if (distance[i][k] < INT_MAX && distance[k][j] < INT_MAX) {
                    distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]);
                }
            }
        }
    }
    return distance;
}

int networkDelayTime(vector<vector<int> > &times, int n, int k) {
    // vector<vector<pair<int, int> > > graph(n);
    // for (const auto &time: times) {
    //     graph[time[0] - 1].emplace_back(time[1] - 1, time[2]);
    // }
    // vector<int> distance = dijkstra(graph, k - 1);
    // int result = 0;
    // for (int i = 0; i < distance.size(); i++) {
    //     if (distance[i] == INT_MAX) {
    //         return -1;
    //     } else {
    //         result = max(result, distance[i]);
    //     }
    // }
    // return result;
    vector<vector<int> > graph(n, vector<int>(n, INT_MAX));
    for (int i = 0; i < n; i++) {
        graph[i][i] = 0;
    }
    for (const auto &time: times) {
        graph[time[0] - 1][time[1] - 1] = time[2];
    }
    vector<vector<int> > distance = floyd(graph);
    int result = 0;
    for (int i = 0; i < distance[k - 1].size(); i++) {
        if (distance[k - 1][i] == INT_MAX) {
            return -1;
        } else {
            result = max(result, distance[k - 1][i]);
        }
    }
    return result;
}
```

#### 多源最短路径（边权同为1/边权同为一个正数）

[542. 01 矩阵](https://leetcode.cn/problems/01-matrix/)

```
vector<vector<int> > bfs(vector<vector<int> > &mat) {
    vector<vector<bool> > visited(mat.size(), vector<bool>(mat[0].size(), false));
    queue<pair<int, int> > q;
    for (int i = 0; i < mat.size(); i++) {
        for (int j = 0; j < mat[i].size(); j++) {
            if (mat[i][j] == 0) {
            	visited[i][j] = true;
                q.emplace(i, j);
            }
        }
    }
    
    vector<vector<int> > distance(mat.size(), vector<int>(mat[0].size(), 0));
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            int x = q.front().first;
            int y = q.front().second;
            q.pop();
            vector<pair<int, int> > directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
            for (const auto &direction: directions) {
                int dx = x + direction.first;
                int dy = y + direction.second;
                if (dx >= 0 && dx < mat.size() && dy >= 0 && dy < mat[dx].size() && !visited[dx][dy]) {
                    visited[dx][dy] = true;
                    distance[dx][dy] = distance[x][y] + 1;
                    q.emplace(dx, dy);
                }
            }
        }
    }

    return distance;
}

vector<vector<int> > updateMatrix(vector<vector<int> > &mat) {
    return bfs(mat);
}
```

[1162. 地图分析](https://leetcode.cn/problems/as-far-from-land-as-possible/)

```
vector<vector<int> > bfs(vector<vector<int> > &grid) {
    vector<vector<bool> > visited(grid.size(), vector<bool>(grid[0].size(), false));
    queue<pair<int, int> > q;
    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[i].size(); j++) {
            if (grid[i][j] == 1) {
                visited[i][j] = true;
                q.push({i, j});
            }
        }
    }

    vector<vector<int> > distance(grid.size(), vector<int>(grid[0].size(), 0));
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            int x = q.front().first;
            int y = q.front().second;
            q.pop();
            vector<pair<int, int> > directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
            for (const auto &direction: directions) {
                int dx = x + direction.first;
                int dy = y + direction.second;
                if (dx >= 0 && dx < grid.size() && dy >= 0 && dy < grid[dx].size() && !visited[dx][dy]) {
                    visited[dx][dy] = true;
                    distance[dx][dy] = distance[x][y] + 1;
                    q.emplace(dx, dy);
                }
            }
        }
    }
    return distance;
}

int maxDistance(vector<vector<int> > &grid) {
    vector<vector<int> > distance = bfs(grid);
    int result = -1;
    for (int i = 0; i < distance.size(); i++) {
        for (int j = 0; j < distance[i].size(); j++) {
            result = max(result, distance[i][j]);
        }
    }
    return result;
}
```

[994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)

```
vector<vector<int> > bfs(vector<vector<int> > &grid) {
    vector<vector<int> > distance(grid.size(), vector<int>(grid[0].size(), -1));
    vector<vector<bool> > visited(grid.size(), vector<bool>(grid[0].size(), false));
    queue<pair<int, int> > q;
    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[i].size(); j++) {
            if (grid[i][j] == 2) {
                distance[i][j] = 0;
                visited[i][j] = true;
                q.push({i, j});
            }
        }
    }

    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            int x = q.front().first;
            int y = q.front().second;
            q.pop();
            vector<pair<int, int> > directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
            for (const auto &direction: directions) {
                int dx = x + direction.first;
                int dy = y + direction.second;
                if (dx >= 0 && dx < grid.size() && dy >= 0 && dy < grid[dx].size() && !visited[dx][dy] && grid[dx][
                        dy]) {
                    visited[dx][dy] = true;
                    distance[dx][dy] = distance[x][y] + 1;
                    q.emplace(dx, dy);
                }
            }
        }
    }
    return distance;
}

int orangesRotting(vector<vector<int> > &grid) {
    vector<vector<int> > distance = bfs(grid);
    int result = 0;
    for (int i = 0; i < distance.size(); i++) {
        for (int j = 0; j < distance[i].size(); j++) {
            if (grid[i][j] == 0 && distance[i][j] == -1 || grid[i][j] == 1 && distance[i][j] > 0 || grid[i][j] == 2
                && distance[i][j] == 0) {
                result = max(result, distance[i][j]);
            } else {
                return -1;
            }
        }
    }
    return result;
}
```

#### 多源最短路径（Floyd算法）

[743. 网络延迟时间](https://leetcode.cn/problems/network-delay-time/)

```
vector<int> dijkstra(vector<vector<pair<int, int> > > &graph, int start) {
    vector<int> distance(graph.size(), INT_MAX);
    distance[start] = 0;
    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<> > pq;
    pq.emplace(0, start);
    while (!pq.empty()) {
        int weight = pq.top().first;
        int u = pq.top().second;
        pq.pop();
        if (weight <= distance[u]) {
            for (const auto &edge: graph[u]) {
                if (distance[edge.first] > distance[u] + edge.second) {
                    distance[edge.first] = distance[u] + edge.second;
                    pq.emplace(distance[edge.first], edge.first);
                }
            }
        }
    }

    return distance;
}

vector<vector<int> > floyd(vector<vector<int> > &graph) {
    vector<vector<int> > distance = graph;
    for (int k = 0; k < distance.size(); k++) {
        for (int i = 0; i < distance.size(); i++) {
            for (int j = 0; j < distance.size(); j++) {
                if (distance[i][k] < INT_MAX && distance[k][j] < INT_MAX) {
                    distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j]);
                }
            }
        }
    }
    return distance;
}

int networkDelayTime(vector<vector<int> > &times, int n, int k) {
    // vector<vector<pair<int, int> > > graph(n);
    // for (const auto &time: times) {
    //     graph[time[0] - 1].emplace_back(time[1] - 1, time[2]);
    // }
    // vector<int> distance = dijkstra(graph, k - 1);
    // int result = 0;
    // for (int i = 0; i < distance.size(); i++) {
    //     if (distance[i] == INT_MAX) {
    //         return -1;
    //     } else {
    //         result = max(result, distance[i]);
    //     }
    // }
    // return result;
    vector<vector<int> > graph(n, vector<int>(n, INT_MAX));
    for (int i = 0; i < n; i++) {
        graph[i][i] = 0;
    }
    for (const auto &time: times) {
        graph[time[0] - 1][time[1] - 1] = time[2];
    }
    vector<vector<int> > distance = floyd(graph);
    int result = 0;
    for (int i = 0; i < distance[k - 1].size(); i++) {
        if (distance[k - 1][i] == INT_MAX) {
            return -1;
        } else {
            result = max(result, distance[k - 1][i]);
        }
    }
    return result;
}
```

### 最小生成树（Kruskal 算法/Prim 算法）

[1584. 连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)

```
class UnionFind {
private:
    vector<int> parent;
    vector<int> size;
    int count;

public:
    UnionFind(int n): parent(n), size(n, 1), count(n) {
        iota(parent.begin(), parent.end(), 0);
    }

    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]);
    }

    bool unite(int x, int y) {
        int xroot = find(x);
        int yroot = find(y);
        if (xroot == yroot) {
            return false;
        }

        if (size[xroot] < size[yroot]) {
            parent[xroot] = yroot;
            size[yroot] += size[xroot];
        } else {
            parent[yroot] = xroot;
            size[xroot] += size[yroot];
        }

        count--;

        return true;
    }

    bool connected(int x, int y) {
        return find(x) == find(y);
    }

    int getCount() const {
        return count;
    }
};

struct Edge {
    int u, v, w;

    bool operator<(const Edge &edge) const {
        return w < edge.w;
    }
};

class Solution {
public:
    int kruskal(vector<vector<int> > &nodes) {
        vector<Edge> edges;
        for (int i = 0; i < nodes.size(); i++) {
            for (int j = i + 1; j < nodes.size(); j++) {
                edges.emplace_back(i, j, abs(nodes[i][0] - nodes[j][0]) + abs(nodes[i][1] - nodes[j][1]));
            }
        }
        sort(edges.begin(), edges.end());

        int count = 0;
        int value = 0;
        UnionFind uf(edges.size() + 1);
        for (const auto &edge: edges) {
            if (!uf.connected(edge.u, edge.v)) {
                uf.unite(edge.u, edge.v);
                value += edge.w;
                count++;
                if (count == edges.size()) {
                    return value;
                }
            }
        }
        return value;
    }

    int prim(vector<vector<int> > &nodes) {
        vector<bool> visited(nodes.size(), false);
        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<> > pq;
        pq.push(make_pair(0, 0));
        int count = 0;
        int value = 0;
        while (count < nodes.size()) {
            int weight = pq.top().first;
            int u = pq.top().second;
            pq.pop();
            if (!visited[u]) {
                visited[u] = true;
                value += weight;
                count++;
                for (int v = 0; v < nodes.size(); v++) {
                    if (!visited[v]) {
                        pq.push(make_pair(abs(nodes[u][0] - nodes[v][0]) + abs(nodes[u][1] - nodes[v][1]), v));
                    }
                }
            }
        }
        return value;
    }

    int minCostConnectPoints(vector<vector<int> > &points) {
        return kruskal(points);
    }
};
```

[1489. 找到最小生成树里的关键边和伪关键边](https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/)

```
class UnionFind {
private:
    vector<int> parent;
    vector<int> size;
    int count;

public:
    UnionFind(int n): parent(n), size(n, 1), count(n) {
        iota(parent.begin(), parent.end(), 0);
    }

    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]);
    }

    bool unite(int x, int y) {
        int xroot = find(x);
        int yroot = find(y);
        if (xroot == yroot) {
            return false;
        }

        if (size[xroot] < size[yroot]) {
            parent[xroot] = yroot;
            size[yroot] += size[xroot];
        } else {
            parent[yroot] = xroot;
            size[xroot] += size[yroot];
        }

        count--;

        return true;
    }

    bool connected(int x, int y) {
        return find(x) == find(y);
    }

    int getCount() const {
        return count;
    }
};

struct Edge {
    int u, v, w;

    bool operator<(const Edge &edge) const {
        return w < edge.w;
    }
};

class Solution {
public:
    int kruskal(vector<vector<int> > &edges) {
        int count = 0;
        int cost = 0;
        UnionFind uf(edges.size() + 1);
        for (const auto &edge: edges) {
            if (!uf.connected(edge[0], edge[1])) {
                uf.unite(edge[0], edge[1]);
                cost += edge[2];
                count++;
                if (count == edges.size()) {
                    return cost;
                }
            }
        }
        return cost;
    }

    vector<vector<int> > findCriticalAndPseudoCriticalEdges(int n, vector<vector<int> > &edges) {
        for (int i = 0; i < edges.size(); i++) {
            edges[i].push_back(i);
        }
        sort(edges.begin(), edges.end(), [](const auto &lhs, const auto &rhs) { return lhs[2] < rhs[2]; });
        int value = kruskal(edges);

        vector<vector<int> > result(2);
        for (int i = 0; i < edges.size(); i++) {
            UnionFind uf1(n);
            int v1 = 0;
            for (int j = 0; j < edges.size(); j++) {
                if (i != j && !uf1.connected(edges[j][0], edges[j][1])) {
                    uf1.unite(edges[j][0], edges[j][1]);
                    v1 += edges[j][2];
                }
            }
            if (uf1.getCount() != 1 || (uf1.getCount() == 1 && v1 > value)) {
                result[0].push_back(edges[i][3]);
                continue;
            }

            UnionFind uf2(n);
            uf2.unite(edges[i][0], edges[i][1]);
            int v2 = edges[i][2];
            for (int j = 0; j < edges.size(); j++) {
                if (i != j && !uf2.connected(edges[j][0], edges[j][1])) {
                    uf2.unite(edges[j][0], edges[j][1]);
                    v2 += edges[j][2];
                }
            }
            if (v2 == value) {
                result[1].push_back(edges[i][3]);
            }
        }
        return result;
    }
};
```

### 二分图

[785. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/)

```
bool bfs(vector<vector<int> > &graph, int node, vector<int> &color) {
    color[node] = 0;
    queue<int> q;
    q.push(node);
    while (!q.empty()) {
        int n = q.front();
        q.pop();
        for (int i = 0; i < graph[n].size(); i++) {
            if (color[graph[n][i]] == -1) {
                color[graph[n][i]] = !color[n];
                q.push(graph[n][i]);
            } else if (color[graph[n][i]] == color[n]) {
                return false;
            }
        }
    }
    return true;
}

bool dfs(vector<vector<int> > &graph, int node, vector<int> &color, int c) {
    color[node] = c;
    for (int i = 0; i < graph[node].size(); i++) {
        if (color[graph[node][i]] == -1) {
            color[graph[node][i]] = !color[node];
            if (!dfs(graph, graph[node][i], color, color[graph[node][i]])) {
                return false;
            }
        } else if (color[graph[node][i]] == color[node]) {
            return false;
        }
    }
    return true;
}

bool isBipartite(vector<vector<int> > &graph) {
    vector<int> color(graph.size(), -1);
    for (int i = 0; i < graph.size(); i++) {
        if (color[i] == -1) {
            // if (!bfs(graph, i, color)) {
            //     return false;
            // }
            if (!dfs(graph, i, color)) {
                return false;
            }
        }
    }
    return true;
}
```

[886. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/)

```
bool bfs(vector<vector<int> > &graph, int node, vector<int> &color) {
    color[node] = 0;
    queue<int> q;
    q.push(node);
    while (!q.empty()) {
        int n = q.front();
        q.pop();
        for (int i = 0; i < graph[n].size(); i++) {
            if (color[graph[n][i]] == -1) {
                color[graph[n][i]] = !color[n];
                q.push(graph[n][i]);
            } else if (color[graph[n][i]] == color[n]) {
                return false;
            }
        }
    }
    return true;
}

bool dfs(vector<vector<int> > &graph, int node, vector<int> &color, int c) {
    color[node] = c;
    for (int i = 0; i < graph[node].size(); i++) {
        if (color[graph[node][i]] == -1) {
            color[graph[node][i]] = !color[node];
            if (!dfs(graph, graph[node][i], color, color[graph[node][i]])) {
                return false;
            }
        } else if (color[graph[node][i]] == color[node]) {
            return false;
        }
    }
    return true;
}

bool possibleBipartition(int n, vector<vector<int> > &dislikes) {
    vector<vector<int> > graph(n);
    for (int i = 0; i < dislikes.size(); i++) {
        graph[dislikes[i][0] - 1].emplace_back(dislikes[i][1] - 1);
        graph[dislikes[i][1] - 1].emplace_back(dislikes[i][0] - 1);
    }

    vector<int> color(n, -1);
    for (int i = 0; i < n; i++) {
        if (color[i] == -1) {
            if (!bfs(graph, i, color)) {
                return false;
            }
            // if (!dfs(graph, i, color, color[i])) {
            //     return false;
            // }
        }
    }
    return true;
}
```

### 并查集

[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

```
class UnionFind {
private:
    vector<int> parent;
    vector<int> size;
    int count;

public:
    UnionFind(int n): parent(n), size(n, 1), count(n) {
        iota(parent.begin(), parent.end(), 0);
    }

    UnionFind(vector<vector<char> > &grid) {
        parent.resize(grid.size() * grid[0].size());
        size.resize(grid.size() * grid[0].size(), 1);
        count = 0;
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[i].size(); j++) {
                if (grid[i][j] == '1') {
                    parent[i * grid[i].size() + j] = i * grid[i].size() + j;
                    count++;
                }
            }
        }
    }

    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]);
    }

    bool unite(int x, int y) {
        int xroot = find(x);
        int yroot = find(y);
        if (xroot == yroot) {
            return false;
        }

        if (size[xroot] < size[yroot]) {
            parent[xroot] = yroot;
            size[yroot] += size[xroot];
        } else {
            parent[yroot] = xroot;
            size[xroot] += size[yroot];
        }

        count--;

        return true;
    }

    bool connected(int x, int y) {
        return find(x) == find(y);
    }

    int getCount() const {
        return count;
    }
};

class Solution {
public:
    int numIslands(vector<vector<char> > &grid) {
        UnionFind uf(grid);
        vector<pair<int, int> > directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[i].size(); j++) {
                if (grid[i][j] == '1') {
                    for (const auto &direction: directions) {
                        int x = i + direction.first;
                        int y = j + direction.second;
                        if (x >= 0 && x < grid.size() && y >= 0 && y < grid[x].size() && grid[x][y] == '1') {
                            uf.unite(i * grid[i].size() + j, x * grid[i].size() + y);
                        }
                    }
                }
            }
        }
        return uf.getCount();
    }
};
```

## 哈希表

### 定义

[705. 设计哈希集合](https://leetcode.cn/problems/design-hashset/)

```
class MyHashSet {
public:
    static const int mod = 1009;
    vector<vector<int> > table;

    int hash(int key) {
        return key % mod;
    }

    MyHashSet() {
        table = vector(mod, vector<int>());
    }

    void add(int key) {
        if (!contains(key)) {
            table[hash(key)].push_back(key);
        }
    }

    void remove(int key) {
        for (vector<int>::iterator it = table[hash(key)].begin(); it != table[hash(key)].end(); it++) {
            if (*it == key) {
                table[hash(key)].erase(it);
                return;
            }
        }
    }

    bool contains(int key) {
        for (vector<int>::iterator it = table[hash(key)].begin(); it != table[hash(key)].end(); it++) {
            if (*it == key) {
                return true;
            }
        }
        return false;
    }
};
```

[706. 设计哈希映射](https://leetcode.cn/problems/design-hashmap/)

```
class MyHashMap {
public:
    static const int base = 1009;
    vector<vector<pair<int, int> > > table;

    int hash(int key) {
        return key % base;
    }

    MyHashMap() {
        table = vector<vector<pair<int, int> > >(base, vector<pair<int, int> >());
    }

    void put(int key, int value) {
        for (vector<pair<int, int> >::iterator it = table[hash(key)].begin(); it != table[hash(key)].end(); it++) {
            if (it->first == key) {
                it->second = value;
                return;
            }
        }
        table[hash(key)].push_back({key, value});
    }

    int get(int key) {
        for (vector<pair<int, int> >::iterator it = table[hash(key)].begin(); it != table[hash(key)].end(); it++) {
            if (it->first == key) {
                return it->second;
            }
        }
        return -1;
    }

    void remove(int key) {
        for (vector<pair<int, int> >::iterator it = table[hash(key)].begin(); it != table[hash(key)].end(); it++) {
            if (it->first == key) {
                table[hash(key)].erase(it);
                return;
            }
        }
    }
};
```

### 基本操作

[217. 存在重复元素](https://leetcode.cn/problems/contains-duplicate/)

```
bool containsDuplicate(vector<int> &nums) {
    unordered_set<int> set(nums.begin(), nums.end());
    return set.size() != nums.size();
}
```

[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

```
vector<int> intersection(vector<int> &nums1, vector<int> &nums2) {
    unordered_set<int> set1(nums1.begin(), nums1.end());
    unordered_set<int> set2(nums2.begin(), nums2.end());
    vector<int> result;
    for (const auto &e: set2) {
        if (set1.count(e)) {
            result.push_back(e);
        }
    }
    return result;
}
```

### 同构

[205. 同构字符串](https://leetcode.cn/problems/isomorphic-strings/)

```
bool isIsomorphic(string s, string t) {
    if (s.length() != t.length()) {
        return false;
    }

    unordered_map<char, char> stot;
    unordered_map<char, char> ttos;
    for (int i = 0; i < s.length(); i++) {
        if (stot.count(s[i]) && stot[s[i]] != t[i] || ttos.count(t[i]) && ttos[t[i]] != s[i]) {
            return false;
        }
        stot[s[i]] = t[i];
        ttos[t[i]] = s[i];
    }
    return true;
}
```

[290. 单词规律](https://leetcode.cn/problems/word-pattern/)

```
bool wordPattern(string pattern, string s) {
    vector<string> words;
    size_t begin = 0;
    size_t end = s.find(' ');
    while (end != string::npos) {
        words.emplace_back(s.substr(begin, end - begin));
        begin = end + 1;
        end = s.find(' ', begin);
    }
    words.emplace_back(s.substr(begin));

    if (words.size() != pattern.size()) {
        return false;
    }

    unordered_map<char, string> ctos;
    unordered_map<string, char> stoc;
    for (int i = 0; i < pattern.size(); i++) {
        if (ctos.count(pattern[i]) && ctos[pattern[i]] != words[i] ||
            stoc.count(words[i]) && stoc[words[i]] != pattern[i]) {
            return false;
        }
        ctos[pattern[i]] = words[i];
        stoc[words[i]] = pattern[i];
    }
    return true;
}
```

### 两数之和

[1. 两数之和](https://leetcode.cn/problems/two-sum/)

```
vector<int> twoSum(vector<int> &nums, int target) {
    unordered_map<int, int> map;
    for (int i = 0; i < nums.size(); i++) {
        if (map.count(target - nums[i])) {
            return {i, map[target - nums[i]]};
        }
        map[nums[i]] = i;
    }
    return {};
}
```

[599. 两个列表的最小索引总和](https://leetcode.cn/problems/minimum-index-sum-of-two-lists/)

```
vector<string> findRestaurant(vector<string> &list1, vector<string> &list2) {
    unordered_map<string, int> map;
    for (int i = 0; i < list1.size(); i++) {
        map[list1[i]] = i;
    }

    int minimum = list1.size() + list2.size();
    for (int i = 0; i < list2.size(); i++) {
        if (map.count(list2[i])) {
            if (map[list2[i]] + i < minimum) {
                minimum = map[list2[i]] + i;
            }
        }
    }

    vector<string> results;
    for (int i = 0; i < list2.size(); i++) {
        if (map.count(list2[i])) {
            if (map[list2[i]] + i == minimum) {
                results.emplace_back(list2[i]);
            }
        }
    }
    return results;
}
```

[219. 存在重复元素 II](https://leetcode.cn/problems/contains-duplicate-ii/)

```
bool containsNearbyDuplicate(vector<int> &nums, int k) {
    unordered_map<int, int> map;
    for (int i = 0; i < nums.size(); i++) {
        if (map.count(nums[i])) {
            if (abs(i - map[nums[i]]) <= k) {
                return true;
            }
        }
        map[nums[i]] = i;
    }
    return false;
}
```

### 前缀和

[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

```
// 前缀和+枚举（超时）
int subarraySum(vector<int> &nums, int k) {
    int counter = 0;
    for (int i = 0; i < nums.size(); i++) {
        int sum = 0;
        for (int j = i; j < nums.size(); j++) {
            sum += nums[j];
            if (sum == k) {
                counter++;
            }
        }
    }
    return counter;
}

// 前缀和+哈希表
int subarraySum(vector<int> &nums, int k) {
    unordered_map<int, int> map;
    map[0] = 1; // 1 表示 nums[0] +nums[1] + ... + nums[i] == k
    int counter = 0;
    int sum = 0;
    for (int i = 0; i < nums.size(); i++) {
        sum += nums[i];
        if (map.count(sum - k)) {
            counter += map[sum - k];
        }
        map[sum]++;
    }
    return counter;
}
```

[523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/)

```
bool checkSubarraySum(vector<int> &nums, int k) {
    unordered_map<int, int> map;
    map[0] = -1;
    int sum = 0;
    for (int i = 0; i < nums.size(); i++) {
        sum += nums[i];
        sum %= k;
        if (map.count(sum)) {
            if (i - map[sum] >= 2) {
                return true;
            }
        } else {
            map[sum] = i;
        }
    }
    return false;
}
```

[525. 连续数组](https://leetcode.cn/problems/contiguous-array/)

```C++
int findMaxLength(vector<int> &nums) {
    unordered_map<int, int> map;
    map[0] = -1;

    int length = 0;
    int sum = 0;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] == 0) {
            sum += -1;
        } else {
            sum += nums[i];
        }

        if (map.count(sum)) {
            length = max(length, i - map[sum]);
        }else{
            map[sum] = i;
        }
    }
    return length;
}
```

## 排序算法

| 排序算法 | 最好时间复杂度 | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度  | 稳定性 |
| -------- | -------------- | -------------- | -------------- | ----------- | ------ |
| 冒泡排序 | $O(n)$         | $O(n^2)$       | $O(n^2)$       | $O(1)$      | 是     |
| 选择排序 | $O(n^2)$       | $O(n^2)$       | $O(n^2)$       | $O(1)$      | 否     |
| 插入排序 | $O(n)$         | $O(n^2)$       | $O(n^2)$       | $O(1)$      | 是     |
| 希尔排序 | $O(n\log{n})$  | 视增量序列而定 | $O(n^2)$       | $O(1)$      | 否     |
| 归并排序 | $O(n\log{n})$  | $O(n\log{n})$  | $O(n\log{n})$  | $O(n)$      | 是     |
| 快速排序 | $O(n\log{n})$  | $O(n\log{n})$  | $O(n^2)$       | $O(\log n)$ | 否     |
| 堆排序   | $O(n\log{n})$  | $O(n\log{n})$  | $O(n\log{n})$  | $O(1)$      | 否     |
| 计数排序 | $O(n+k)$       | $O(n+k)$       | $O(n+k)$     | $O(k)$      | 是     |
| 桶排序   | $O(n)$（均匀） | $O(n+k)$     | $O(n^2)$       | $O(n+k)$  | 是     |
| 基数排序 | $O(nk)$        | $O(nk)$        | $O(nk)$        | $O(n+k)$  | 是     |

### 冒泡排序

#### 算法模板

```
vector<int> sort(vector<int> &nums) {
    for (int i = 0; i < nums.size(); i++) {
        bool swapped = false;
        for (int j = 1; j < nums.size() - i; j++) {
            if (nums[j - 1] > nums[j]) {
                swap(nums[j - 1], nums[j]);
                swapped = true;
            }
        }
        if (!swapped) {
            break;
        }
    }
    return nums;
}
```

### 选择排序

#### 算法模板

```
vector<int> sort(vector<int> &nums) {
    for (int i = 0; i < nums.size(); i++) {
        int index = i;
        for (int j = i + 1; j < nums.size(); j++) {
            if (nums[j] < nums[index]) {
                index = j;
            }
        }
        swap(nums[i], nums[index]);
    }
    return nums;
}
```

### 插入排序

#### 算法模板

```
vector<int> sort(vector<int> &nums) {
    for (int i = 0; i < nums.size(); i++) {
        int element = nums[i];
        int j = i - 1;
        while (j >= 0 && nums[j] > element) {
            nums[j + 1] = nums[j];
            j--;
        }
        nums[j + 1] = element;
    }
    return nums;
}
```

### 归并排序

#### 算法模板

模板一

```
void merge(vector<int> &nums, int left, int mid, int right) {
    vector<int> result(right - left + 1);
    int i = left;
    int j = mid + 1;
    int k = 0;
    while (i <= mid && j <= right) {
        if (nums[i] <= nums[j]) {
            result[k++] = nums[i++];
        } else {
            result[k++] = nums[j++];
        }
    }
    while (i <= mid) {
        result[k++] = nums[i++];
    }
    while (j <= right) {
        result[k++] = nums[j++];
    }
    for (int i = 0; i < k; i++) {
        nums[left + i] = result[i];
    }
}

void merge(vector<int> &nums, int left, int right) {
    if (left >= right) {
        return;
    }
    int mid = left + (right - left) / 2;
    merge(nums, left, mid);
    merge(nums, mid + 1, right);
    merge(nums, left, mid, right);
}

vector<int> sort(vector<int> &nums) {
    merge(nums, 0, nums.size() - 1);
    return nums;
}
```

模板二

```
vector<int> merge(const vector<int> &nums1, const vector<int> &nums2) {
    vector<int> result;
    int i = 0;
    int j = 0;
    while (i < nums1.size() && j < nums2.size()) {
        if (nums1[i] <= nums2[j]) {
            result.emplace_back(nums1[i++]);
        } else {
            result.emplace_back(nums2[j++]);
        }
    }
    while (i < nums1.size()) {
        result.emplace_back(nums1[i++]);
    }
    while (j < nums2.size()) {
        result.emplace_back(nums2[j++]);
    }
    return result;
}

vector<int> merge(const vector<int> &nums) {
    if (nums.size() <= 1) {
        return nums;
    }
    int mid = nums.size() / 2;
    vector<int> left(nums.begin(), nums.begin() + mid);
    vector<int> right(nums.begin() + mid, nums.end());
    return merge(merge(left), merge(right));
}

vector<int> sort(vector<int> &nums) {
    return merge(nums);
}
```

### 快速排序

#### 算法模板

模板一（Lomuto 分区法）

```
int partition(vector<int> &nums, int left, int right) {
    int pivot = nums[right];
    int i = left;
    for (int j = left; j < right; ++j) {
        if (nums[j] <= pivot) {
            std::swap(nums[i], nums[j]);
            i++;
        }
    }
    std::swap(nums[i], nums[right]);
    return i;
}

void sort(vector<int> &nums, int left, int right) {
    if (left >= right) {
        return;
    }

    int mid = partition(nums, left, right);
    sort(nums, left, mid - 1);
    sort(nums, mid + 1, right);
}

vector<int> sort(vector<int> &nums) {
    sort(nums, 0, nums.size() - 1);
    return nums;
}
```

模板二（Hoare 分区法）

```
int partition(vector<int> &nums, int left, int right) {
    int pivot = nums[left];
    int i = left - 1;
    int j = right + 1;

    while (true) {
        do { ++i; } while (nums[i] < pivot);
        do { --j; } while (nums[j] > pivot);
        if (i >= j) break;
        std::swap(nums[i], nums[j]);
    }
    return j;
}

void sort(vector<int> &nums, int left, int right) {
    if (left >= right) {
        return;
    }

    int mid = partition(nums, left, right);
    sort(nums, left, mid);
    sort(nums, mid + 1, right);
}

vector<int> sort(vector<int> &nums) {
    sort(nums, 0, nums.size() - 1);
    return nums;
}
```

### 堆排序

#### 算法模板

```
void heapify(vector<int> &nums, int size, int root) {
    int largest = root;
    int left = 2 * root + 1;
    int right = 2 * root + 2;
    if (left < size && nums[left] > nums[largest]) {
        largest = left;
    }
    if (right < size && nums[right] > nums[largest]) {
        largest = right;
    }
    if (largest != root) {
        swap(nums[root], nums[largest]);
        heapify(nums, size, largest);
    }
}

vector<int> sort(vector<int> &nums) {
    for (int i = nums.size() / 2 - 1; i >= 0; i--) {
        heapify(nums, nums.size(), i);
    }
    for (int i = nums.size() - 1; i > 0; i--) {
        swap(nums[0], nums[i]);
        heapify(nums, i, 0);
    }
    return nums;
}
```

## 回溯算法

### 求解模板

```
void backtrack(参数列表) {
    if (终止条件) {
        处理结果;
        return;
    }

    for (选择 : 当前所有可选项) {
        执行选择;
        backtrack(更新参数);
        撤销选择;
    }
}
```

### 回溯问题

[39. 组合总和](https://leetcode.cn/problems/combination-sum/)

```
vector<vector<int> > combinationSum(vector<int> &candidates, int target) {
    vector<vector<int> > result;
    vector<int> numbers;
    backtrack(candidates, target, 0, result, numbers);
    return result;
}

void backtrack(vector<int> &candidates, int target, int index, vector<vector<int> > &result, vector<int> &numbers) {
    if (!target) {
        result.emplace_back(numbers);
        return;
    }

    for (int i = index; i < candidates.size(); i++) {
        if (target >= candidates[i]) {
            numbers.emplace_back(candidates[i]);
            backtrack(candidates, target - candidates[i], i, result, numbers);
            numbers.pop_back();
        }
    }
}
```

[全排列](https://leetcode.cn/problems/permutations/)

```
vector<vector<int> > permute(vector<int> &nums) {
    vector<vector<int> > result;
    for (int i = 0; i < nums.size(); i++) {
        vector<bool> visited(nums.size(), false);
        vector<int> numbers;
        visited[i] = true;
        numbers.push_back(nums[i]);
        backtrack(nums, visited, i, numbers, result);
    }
    return result;
}

void backtrack(vector<int> &nums, vector<bool> &visited, int index, vector<int> &numbers,
               vector<vector<int> > &result) {
    if (numbers.size() == nums.size()) {
        result.push_back(numbers);
        return;
    }

    for (int i = 0; i < nums.size(); i++) {
        if (!visited[i]) {
            visited[i] = true;
            numbers.push_back(nums[i]);
            backtrack(nums, visited, i, numbers, result);
            visited[i] = false;
            numbers.pop_back();
        }
    }
}
```

[79. 单词搜索](https://leetcode.cn/problems/word-search/)

```
bool exist(vector<vector<char> > &board, string word) {
    for (int i = 0; i < board.size(); i++) {
        for (int j = 0; j < board[i].size(); j++) {
            vector<vector<bool> > visited(board.size(), vector<bool>(board[0].size(), false));
            if (board[i][j] == word[0]) {
                if (dfs(board, visited, i, j, word, 0)) {
                    return true;
                }
            }
        }
    }
    return false;
}

bool dfs(vector<vector<char> > &board, vector<vector<bool> > &visited, int row, int column, string &word,
         int index) {
    if (row < 0 || row >= board.size() || column < 0 || column >= board[0].size() || visited[row][column]) {
        return false;
    }

    if (index == word.size()) {
        return true;
    }

    if (board[row][column] == word[index]) {
        visited[row][column] = true;

        if (index + 1 == word.size()) {
            return true;
        }

        if (dfs(board, visited, row - 1, column, word, index + 1)) {
            return true;
        }

        if (dfs(board, visited, row + 1, column, word, index + 1)) {
            return true;
        }

        if (dfs(board, visited, row, column - 1, word, index + 1)) {
            return true;
        }

        if (dfs(board, visited, row, column + 1, word, index + 1)) {
            return true;
        }

        visited[row][column] = false;

        return false;
    }

    return false;
}
```

[51. N 皇后](https://leetcode.cn/problems/n-queens/)

```
vector<vector<string> > solveNQueens(int n) {
    vector<vector<string> > result;
    vector<string> board;
    vector<int> queens(n, -1);
    unordered_set<int> columns;
    unordered_set<int> diagonals1;
    unordered_set<int> diagonals2;
    backtrack(n, result, 0, queens, columns, diagonals1, diagonals2);
    return result;
}

void backtrack(int n, vector<vector<string> > &result, int i, vector<int> &queens, unordered_set<int> &columns,
               unordered_set<int> &diagonals1, unordered_set<int> &diagonals2) {
    if (i == n) {
        vector<string> board(n, string(n, '.'));
        for (int i = 0; i < n; i++) {
            board[i][queens[i]] = 'Q';
        }
        result.push_back(board);
        return;
    }

    for (int j = 0; j < n; j++) {
        if (!columns.contains(j) && !diagonals1.contains(i + j) && !diagonals2.
            contains(i - j)) {
            queens[i] = j;
            columns.insert(j);
            diagonals1.insert(i + j);
            diagonals2.insert(i - j);
            backtrack(n, result, i + 1, queens, columns, diagonals1, diagonals2);
            queens[i] = -1;
            columns.erase(j);
            diagonals1.erase(i + j);
            diagonals2.erase(i - j);
        }
    }
}
```

[37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

```
void solveSudoku(vector<vector<char> > &board) {
    bool valid = false;
    vector<vector<bool> > rows(9, vector<bool>(9, false));
    vector<vector<bool> > columns(9, vector<bool>(9, false));
    vector<vector<vector<bool> > > boxes(3, vector<vector<bool> >(3, vector<bool>(9, false)));
    vector<pair<int, int> > indices;
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] == '.') {
                indices.emplace_back(i, j);
            } else {
                int digit = static_cast<int>(board[i][j] - '0');
                rows[i][digit - 1] = true;
                columns[j][digit - 1] = true;
                boxes[i / 3][j / 3][digit - 1] = true;
            }
        }
    }
    backtrack(board, 0, valid, rows, columns, boxes, indices);
}

void backtrack(vector<vector<char> > &board, int index, bool &valid, vector<vector<bool> > &rows,
               vector<vector<bool> > &columns,
               vector<vector<vector<bool> > > &boxes, vector<pair<int, int> > &indices) {
    if (index == indices.size()) {
        valid = true;
        return;
    }

    int i = indices[index].first;
    int j = indices[index].second;
    for (int k = 0; k < 9; k++) {
        if (!valid && !rows[i][k] && !columns[j][k] && !boxes[i / 3][j / 3][k]) {
            board[i][j] = static_cast<char>('0' + k + 1);
            rows[i][k] = true;
            columns[j][k] = true;
            boxes[i / 3][j / 3][k] = true;
            backtrack(board, index + 1, valid, rows, columns, boxes, indices);
            rows[i][k] = false;
            columns[j][k] = false;
            boxes[i / 3][j / 3][k] = false;
        }
    }
}
```

## 动态规划

### 线性DP

#### 递推

[509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

```
int fib(int n) {
    if (n < 2) {
        return n;
    }
    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i < dp.size(); i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

#### 爬楼梯

[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

```
int climbStairs(int n) {
    if (n < 2) {
        return n;
    }
    vector<int> dp(n + 1);
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i < dp.size(); i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

[377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

```
int combinationSum4(vector<int> &nums, int target) {
    vector<unsigned long long> dp(target + 1, 0);
    dp[0] = 1;
    for (int i = 1; i <= target; i++) {
        for (int j = 0; j < nums.size(); j++) {
            if (i >= nums[j]) {
                dp[i] += dp[i - nums[j]];
            }
        }
    }
    return static_cast<int>(dp[target]);
}
```

#### 打家劫舍

[198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

```
int rob(vector<int> &nums) {
    if (nums.size() == 0) {
        return 0;
    } else if (nums.size() == 1) {
        return nums[0];
    } else if (nums.size() == 2) {
        return max(nums[0], nums[1]);
    } else {
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[nums.size() - 1];
    }
}
```

[213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

```
int rob(vector<int> &nums, int left, int right) {
    if (left == right) {
        return 0;
    } else if (left == right - 1) {
        return nums[left];
    } else if (left == right - 2) {
        return max(nums[left], nums[left + 1]);
    } else {
        vector<int> dp(right - left);
        dp[0] = nums[left];
        dp[1] = max(nums[left], nums[left + 1]);
        for (int i = left + 2; i < right; i++) {
            dp[i - left] = max(dp[i - left - 1], dp[i - left - 2] + nums[i]);
        }
        return dp[right - left - 1];
    }
}

int rob(vector<int> &nums) {
    return max(rob(nums, 1, nums.size()), nums[0] + rob(nums, 2, nums.size() - 1));
}
```

#### 最大子数组和

[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

```
int maxSubArray(vector<int> &nums) {
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        dp[i] = max(dp[i - 1] + nums[i], nums[i]);
    }
    return *max_element(dp.begin(), dp.end());
}
```

#### 最长公共子序列

#### 最长递增子序列

[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

```
int lengthOfLIS(vector<int> &nums) {
    if (nums.size() == 1) {
        return 1;
    }

    vector<int> dp(nums.size(), 1);
    dp[0] = 1;
    for (int i = 1; i < nums.size(); i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }
    return *max_element(dp.begin(), dp.end());
}
```

### 二维DP

#### 不同路径

[62. 不同路径](https://leetcode.cn/problems/unique-paths/)

```
int uniquePaths(int m, int n) {
    vector<vector<int> > dp(m, vector<int>(n, 0));
    for (int i = 0; i < n; i++) {
        dp[0][i] = 1;
    }
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

[63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

```
int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {
    int m = obstacleGrid.size();
    int n = obstacleGrid.front().size();
    vector<vector<int> > dp(m, vector<int>(n, 0));
    for (int i = 0; i < n && !obstacleGrid[0][i]; i++) {
        dp[0][i] = 1;
    }
    for (int i = 0; i < m && !obstacleGrid[i][0]; i++) {
        dp[i][0] = 1;
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = obstacleGrid[i][j] ? 0 : dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

[64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

```
int minPathSum(vector<vector<int> > &grid) {
    vector<vector<int> > dp(grid.size(), vector<int>(grid[0].size(), 0));
    dp[0][0] = grid[0][0];
    for (int i = 1; i < grid[0].size(); i++) {
        dp[0][i] = dp[0][i - 1] + grid[0][i];
    }
    for (int i = 1; i < grid.size(); i++) {
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    }
    for (int i = 1; i < grid.size(); i++) {
        for (int j = 1; j < grid[i].size(); j++) {
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }
    return dp[dp.size() - 1][dp[0].size() - 1];
}
```

### 背包

#### 0-1背包

[494. 目标和](https://leetcode.cn/problems/target-sum/)

```
int findTargetSumWays(vector<int> &nums, int target) {
    int sum = accumulate(nums.begin(), nums.end(), 0);
    target = (target + sum);
    if (target < 0 || target % 2) {
        return 0;
    }
    target /= 2;

    vector<vector<int> > dp(nums.size() + 1, vector<int>(target + 1, 0));
    dp[0][0] = 1;
    for (int i = 1; i <= nums.size(); i++) {
        for (int j = 0; j <= target; j++) {
            if (j < nums[i - 1]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];
            }
        }
    }
    return dp[nums.size()][target];
}
```

[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

```
bool canPartition(vector<int> &nums) {
    int sum = accumulate(nums.begin(), nums.end(), 0);
    if (sum % 2) {
        return false;
    }
    int target = sum / 2;

    vector<vector<bool> > dp(nums.size() + 1, vector<bool>(target + 1, false));
    dp[0][0] = true;
    for (int i = 1; i <= nums.size(); i++) {
        for (int j = 0; j <= target; j++) {
            if (j < nums[i - 1]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
            }
        }
    }
    return dp[nums.size()][target];
}
```

[1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

```
int lastStoneWeightII(vector<int> &stones) {
    int sum = accumulate(stones.begin(), stones.end(), 0);
    int target = sum / 2;

    vector<vector<int> > dp(stones.size() + 1, vector<int>(target + 1, 0));
    for (int i = 0; i <= target; i++) {
        dp[0][i] = 0;
    }
    for (int i = 1; i <= stones.size(); i++) {
        for (int j = 0; j <= target; j++) {
            if (j < stones[i - 1]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - stones[i - 1]] + stones[i - 1]);
            }
        }
    }
    return sum - 2 * dp[stones.size()][target];
}
```

#### 完全背包

[322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

```
int coinChange(vector<int> &coins, int amount) {
    vector<vector<int> > dp(coins.size() + 1, vector<int>(amount + 1, INT_MAX / 2));
    dp[0][0] = 0;
    for (int i = 1; i <= coins.size(); i++) {
        for (int j = 0; j <= amount; j++) {
            if (j < coins[i - 1]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = min(dp[i - 1][j], dp[i][j - coins[i - 1]] + 1);
            }
        }
    }
    return dp[coins.size()][amount] != INT_MAX / 2 ? dp[coins.size()][amount] : -1;
}
```

[518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

```
int change(int amount, vector<int> &coins) {
    vector<vector<unsigned long long> > dp(coins.size() + 1, vector<unsigned long long>(amount + 1, 0));
    dp[0][0] = 1;
    for (int i = 1; i <= coins.size(); i++) {
        for (int j = 0; j <= amount; j++) {
            if (j < coins[i - 1]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]];
            }
        }
    }
    return static_cast<int>(dp[coins.size()][amount]);
}
```

[279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

```
int numSquares(int n) {
    vector<int> nums;
    for (int i = 1; i * i <= n; i++) {
        nums.emplace_back(i * i);
    }

    vector<vector<int> > dp(nums.size() + 1, vector<int>(n + 1,INT_MAX));
    dp[0][0] = 0;
    for (int i = 1; i <= nums.size(); i++) {
        for (int j = 0; j <= n; j++) {
            if (j < nums[i - 1]) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = min(dp[i - 1][j], dp[i][j - nums[i - 1]] + 1);
            }
        }
    }
    return dp[nums.size()][n];
}
```

### 状态机DP

#### 买卖股票的最佳时期

[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

```
int maxProfit(vector<int> &prices) {
    vector<vector<int> > dp(prices.size(), vector<int>(2, 0));
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for (int i = 1; i < prices.size(); i++) {
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    return dp[prices.size() - 1][0];
}
```

[714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

```
int maxProfit(vector<int> &prices, int fee) {
    vector<vector<int> > dp(prices.size(), vector<int>(2, -fee));
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for (int i = 1; i < prices.size(); i++) {
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);
        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    return dp[prices.size() - 1][0];
}
```

## 贪心算法

### 区间互斥

[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

```
int eraseOverlapIntervals(vector<vector<int> > &intervals) {
    if (intervals.empty()) {
        return 0;
    }

    std::sort(intervals.begin(), intervals.end(), [](const vector<int> &a, const vector<int> &b) {
        return a[1] < b[1];
    });

    int result = 1;
    int end = intervals[0][1];
    for (int i = 1; i < intervals.size(); i++) {
        if (intervals[i][0] >= end) {
            end = intervals[i][1];
            result++;
        }
    }
    return intervals.size() - result;
}
```

[452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

```
int findMinArrowShots(vector<vector<int> > &points) {
    if (points.empty()) {
        return 0;
    }
    sort(points.begin(), points.end(), [](const vector<int> &a, const vector<int> &b) {
        return a[1] < b[1];
    });

    int result = 1;
    int end = points[0][1];
    for (int i = 1; i < points.size(); i++) {
        if (points[i][0] > end) {
            end = points[i][1];
            result++;
        }
    }
    return result;
}
```

## 分治算法

### 求解模板

```
ReturnType divide(问题) {
    if (最小规模) {
        return 求解结果;
    }

    auto 左边求解结果 = divide(左边部分子问题);
    auto 右边求解结果 = divide(右边部分子问题);

    return merge(左边求解结果, 右边求解结果);
}
```

### 分治问题

[69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

```
int mySqrt(int x) {
    int left = 0;
    int right = x;
    int result = -1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if ((long long) mid * mid <= x) {
            result = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}
```

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```
vector<int> searchRange(vector<int> &nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            int begin = mid - 1;
            while (begin >= 0 && nums[begin] == target) {
                begin--;
            }
            int end = mid + 1;
            while (end < nums.size() && nums[end] == target) {
                end++;
            }
            return {begin + 1, end - 1};
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return {-1, -1};
}
```

[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

```
ListNode *mergeKLists(vector<ListNode *> &lists) {
    return merge(lists, 0, lists.size() - 1);
}

ListNode *merge(vector<ListNode *> &lists, int left, int right) {
    if (left == right) {
        return lists[left];
    } else if (left > right) {
        return nullptr;
    } else {
        int mid = left + (right - left) / 2;
        return merge(merge(lists, left, mid), merge(lists, mid + 1, right));
    }
}

ListNode *merge(ListNode *p, ListNode *q) {
    ListNode head;
    ListNode *tail = &head;
    while (p && q) {
        if (p->val <= q->val) {
            tail->next = p;
            p = p->next;
        } else {
            tail->next = q;
            q = q->next;
        }
        tail = tail->next;
    }

    if (p) {
        tail->next = p;
    }
    if (q) {
        tail->next = q;
    }

    return head.next;
}
```

## 二分查找

### 数组的二分查找

[704. 二分查找](https://leetcode.cn/problems/binary-search/)

```
int search(vector<int> &nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

### 矩阵的二分查找

[74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

```
// 转化为一维数组
bool searchMatrix(vector<vector<int> > &matrix, int target) {
    int m = matrix.size();
    int n = matrix[0].size();
    int left = 0;
    int right = m * n - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        int x = matrix[mid / n][mid % n];
        if (x == target) {
            return true;
        } else if (x < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return false;
}

// 左下
bool searchMatrix(vector<vector<int> > &matrix, int target) {
    int row = matrix.size() - 1;
    int column = 0;
    while (row >= 0 && column < matrix.front().size()) {
        if (matrix[row][column] == target) {
            return true;
        } else if (matrix[row][column] < target) {
            column++;
        } else {
            row--;
        }
    }
    return false;
}
```

[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

```
// 右上
bool searchMatrix(vector<vector<int> > &matrix, int target) {
    int row = 0;
    int column = matrix.front().size() - 1;
    while (row < matrix.size() && column >= 0) {
        if (matrix[row][column] == target) {
            return true;
        } else if (matrix[row][column] < target) {
            row++;
        } else {
            column--;
        }
    }
    return false;
}

// 左下
bool searchMatrix(vector<vector<int> > &matrix, int target) {
    int row = matrix.size() - 1;
    int column = 0;
    while (row >= 0 && column < matrix.front().size()) {
        if (matrix[row][column] == target) {
            return true;
        } else if (matrix[row][column] < target) {
            column++;
        } else {
            row--;
        }
    }
    return false;
}
```

[162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

```
int findPeakElement(vector<int> &nums) {
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > nums[mid + 1]) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

[852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)

```
int peakIndexInMountainArray(vector<int> &arr) {
    int left = 0;
    int right = arr.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] > arr[mid + 1]) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

### 旋转排列数组的二分查找

[153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

```
int findMin(vector<int> &nums) {
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < nums[right]) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return nums[left];
}
```

[154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

```
int findMin(vector<int> &nums) {
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < nums[right]) {
            right = mid;
        } else if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            right--;
        }
    }
    return nums[left];
}
```

[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```
int search(vector<int> &nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target <= nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] <= target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return -1;
}
```

[81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)

```
bool search(vector<int> &nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return true;
        }

        if (nums[left] == nums[mid] && nums[mid] == nums[right]) {
            left++;
            right--;
        } else if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target <= nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] <= target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return false;
}
```

## 双指针

### 双指针对撞

[167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

```
vector<int> twoSum(vector<int> &numbers, int target) {
    int left = 0;
    int right = numbers.size() - 1;
    while (left < right) {
        int sum = numbers[left] + numbers[right];
        if (sum == target) {
            return {left + 1, right + 1};
        } else if (sum > target) {
            right--;
        } else {
            left++;
        }
    }
    return {};
}
```

[15. 三数之和](https://leetcode.cn/problems/3sum/)

```
vector<vector<int> > threeSum(vector<int> &nums) {
	if (nums.size() < 3) {
        return {};
    }
    
    sort(nums.begin(), nums.end());
    vector<vector<int> > result;
    for (int i = 0; i < nums.size() - 2; i++) {
        if (i == 0 || nums[i] != nums[i - 1]) {
            int left = i + 1;
            int right = nums.size() - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    result.push_back({nums[i], nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    while (left < right && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    left++;
                    right--;
                } else if (sum > 0) {
                    right--;
                } else {
                    left++;
                }
            }
        }
    }
    return result;
}
```

[18. 四数之和](https://leetcode.cn/problems/4sum/)

```
vector<vector<int> > fourSum(vector<int> &nums, int target) {
    if (nums.size() < 4) {
        return {};
    }

    sort(nums.begin(), nums.end());
    vector<vector<int> > result;
    for (int i = 0; i < nums.size() - 3; i++) {
        if (i == 0 || nums[i] != nums[i - 1]) {
            for (int j = i + 1; j < nums.size() - 2; j++) {
                if (j == i + 1 || nums[j] != nums[j - 1]) {
                    int left = j + 1;
                    int right = nums.size() - 1;
                    while (left < right) {
                        long long sum = static_cast<long long>(nums[i]) + nums[j] + nums[left] + nums[right];
                        if (sum == target) {
                            result.push_back({nums[i], nums[j], nums[left], nums[right]});
                            while (left < right && nums[left] == nums[left + 1]) {
                                left++;
                            }
                            while (left < right && nums[right] == nums[right - 1]) {
                                right--;
                            }
                            left++;
                            right--;
                        } else if (sum > target) {
                            right--;
                        } else {
                            left++;
                        }
                    }
                }
            }
        }
    }
    return result;
}
```

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

```
void reverseString(vector<char> &s) {
    int left = 0;
    int right = s.size() - 1;
    while (left < right) {
        swap(s[left], s[right]);
        left++;
        right--;
    }
}
```

[125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)

```
bool isPalindrome(string s) {
    string str = "";
    for (const auto &c: s) {
        if (isalpha(c) || isdigit(c)) {
            str += static_cast<char>(tolower(c));
        }
    }

    int left = 0;
    int right = str.length() - 1;
    while (left < right) {
        if (str[left] != str[right]) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
```

[345. 反转字符串中的元音字母](https://leetcode.cn/problems/reverse-vowels-of-a-string/)

```
string reverseVowels(string s) {
    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'O', 'I', 'O', 'U'};
    int left = 0;
    int right = s.length() - 1;
    while (left < right) {
        while (left < right && !vowels.contains(s[left])) {
            left++;
        }
        while (right > left && !vowels.contains(s[right])) {
            right--;
        }
        swap(s[left], s[right]);
        left++;
        right--;
    }
    return s;
}
```

[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

```
// 暴力（超时）
int maxArea(vector<int> &height) {
    int result = 0;
    for (int i = 0; i < height.size(); i++) {
        for (int j = 0; j < height.size(); j++) {
            result = max(result, min(height[i], height[j]) * abs(j - i));
        }
    }
    return result;
}

// 双指针
int maxArea(vector<int> &height) {
    int left = 0;
    int right = height.size() - 1;
    int result = 0;
    while (left < right) {
        result = max(result, min(height[left], height[right]) * (right - left));
        if (height[left] <= height[right]) {
            left++;
        } else {
            right--;
        }
    }
    return result;
}
```

### 快慢指针

[19. 删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```
ListNode *removeNthFromEnd(ListNode *head, int n) {
    ListNode dummy(0, head);
    ListNode *slow = &dummy;
    ListNode *fast = head;
    for (int i = 0; i < n; i++) {
        fast = fast->next;
    }
    while (fast) {
        fast = fast->next;
        slow = slow->next;
    }
    ListNode *node = slow->next;
    slow->next = slow->next->next;
    delete node;
    return dummy.next;
}
```

[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

```C++
// 写法一（链表长度为奇数时slow指向中点，链表长度为偶数时slow指向后半部分开头）
ListNode *middleNode(ListNode *head) {
    ListNode *slow = head;
    ListNode *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return slow;
}

// 写法二（链表长度为奇数时slow指向中点，链表长度为偶数时slow指向前半部分结尾）
ListNode *middleNode(ListNode *head) {
    ListNode *slow = head;
    ListNode *fast = head;
    while (fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
    }
    return fast->next ? slow->next : slow;
}
```

[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

```C++
bool hasCycle(ListNode *head) {
    ListNode *slow = head;
    ListNode *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
```

[142. 环形链表Ⅱ](https://leetcode.cn/problems/linked-list-cycle-ii/)

```
ListNode *detectCycle(ListNode *head) {
    ListNode *slow = head;
    ListNode *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            ListNode *node = head;
            while (node != slow) {
                slow = slow->next;
                node = node->next;
            }
            return node;
        }
    }
    return nullptr;
}
```

### 其他

[283. 移动零](https://leetcode.cn/problems/move-zeroes/)

```
void moveZeroes(vector<int> &nums) {
    int index = 0;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != 0) {
            nums[index] = nums[i];
            index++;
        }
    }
    for (int i = index; i < nums.size(); i++) {
        nums[i] = 0;
    }
}
```

[27. 移除元素](https://leetcode.cn/problems/remove-element/)

```
int removeElement(vector<int> &nums, int val) {
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] == val) {
            nums[i] = -1;
        }
    }
    int index = 0;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != -1) {
            nums[index] = nums[i];
            index++;
        }
    }
    return index;
}
```

[86.  分隔链表](https://leetcode.cn/problems/partition-list/)

```
ListNode *partition(ListNode *head, int x) {
    ListNode lhead(0, head);
    ListNode *ltail = &lhead;

    ListNode rhead(0, head);
    ListNode *rtail = &rhead;

    while (head) {
        if (head->val < x) {
            ltail->next = head;
            ltail = ltail->next;
        } else {
            rtail->next = head;
            rtail = rtail->next;
        }
        head = head->next;
    }
    rtail->next = nullptr;
    ltail->next = rhead.next;

    return lhead.next;
}
```

[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

```C++
// 哈希表
ListNode* getIntersectionNodeByMap(ListNode *list1, ListNode *list2) {
	map<ListNode *, bool> map;
    for (ListNode *curr = list1; curr; curr = curr->next) {
        map.insert(make_pair(curr, true));
    }
    for (ListNode *curr = list2; curr; curr = curr->next) {
        if (map.count(curr)) {
            return curr;
        }
    }
    return nullptr;
}

// 暴力枚举
ListNode *getIntersectionNodeByEnumerate(ListNode *list1, ListNode *list2) {
    for (ListNode *i = list1; i; i = i->next) {
        for (ListNode *j = list2; j; j = j->next) {
            if (i == j) {
                return j;
            }
        }
    }
    return nullptr;
}

// 截取
ListNode *getIntersectionNode(ListNode *list1, ListNode *list2) {
    size_t size1 = getListSize(list1);
    size_t size2 = getListSize(list2);

    ListNode *slow = nullptr;
    ListNode *fast = nullptr;
    size_t diff = 0;
    if (sizeA > sizeB) {
        diff = size1 - size2;
        slow = head2;
        fast = head1;
    } else {
        diff = size2 - size1;
        slow = head1;
        fast = head2;
    }

    while (diff--) {
        fast = fast->next;
    }

    while (fast) {
        if (fast == slow) {
            return slow;
        }
        fast = fast->next;
        slow = slow->next;
    }
    return nullptr;
}

// 补齐
ListNode *getIntersectionNode(ListNode *list1, ListNode *list2) {
    ListNode *p1 = list1, *p2 = list2;
    while (p1 != p2) {
        p1 = p1 == nullptr ? list2 : p1->next;
        p2 = p2 == nullptr ? list1 : p2->next;
    }
    return p1;
}
```

## 滑动窗口

### 定长滑动窗口

[567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)

```
bool checkInclusion(string s1, string s2) {
    unordered_map<char, int> need;
    for (int i = 0; i < s1.length(); i++) {
        need[s1[i]]++;
    }
    int left = 0;
    int right = 0;
    int valid = 0;
    unordered_map<char, int> window;
    while (right < s2.length()) {
        if (need.contains(s2[right])) {
            window[s2[right]]++;
            if (window[s2[right]] == need[s2[right]]) {
                valid++;
            }
        }
        while (valid == need.size()) {
            if (right - left + 1 == s1.length()) {
                return true;
            }
            if (need.contains(s2[left])) {
                if (window[s2[left]] == need[s2[left]]) {
                    valid--;
                }
                window[s2[left]]--;
            }
            left++;
        }
        right++;
    }
    return false;
}
```

[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```
vector<int> findAnagrams(string s, string p) {
    vector<int> result;
    unordered_map<char, int> need;
    for (int i = 0; i < p.length(); i++) {
        need[p[i]]++;
    }
    int left = 0;
    int right = 0;
    int valid = 0;
    unordered_map<char, int> window;
    while (right < s.length()) {
        if (need.contains(s[right])) {
            window[s[right]]++;
            if (window[s[right]] == need[s[right]]) {
                valid++;
            }
        }
        while (valid == need.size()) {
            if (right - left + 1 == p.length()) {
                result.emplace_back(left);
            }
            if (need.contains(s[left])) {
                if (window[s[left]] == need[s[left]]) {
                    valid--;
                }
                window[s[left]]--;
            }
            left++;
        }
        right++;
    }
    return result;
}
```

### 不定长滑动窗口

[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```
int minSubArrayLen(int target, vector<int> &nums) {
    int result = INT_MAX;
    int left = 0;
    int right = 0;
    int sum = 0;
    while (right < nums.size()) {
        sum += nums[right];
        while (sum >= target) {
            result = min(result, right - left + 1);
            sum -= nums[left];
            left++;
        }
        right++;
    }
    return result == INT_MAX ? 0 : result;
}
```

[904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

```
int totalFruit(vector<int> &fruits) {
    int result = 0;
    int left = 0;
    int right = 0;
    unordered_map<int, int> window;
    while (right < fruits.size()) {
        window[fruits[right]]++;
        while (window.size() > 2) {
            if (window.contains(fruits[left])) {
                window[fruits[left]]--;
                if (window[fruits[left]] == 0) {
                    window.erase(fruits[left]);
                }
            }
            left++;
        }
        result = max(result, right - left + 1);
        right++;
    }
    return result;
}
```

## 前缀和

### 数组的前缀和

[303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

```C++
class NumArray {
private:
    vector<int> sums;
public:
    NumArray(vector<int> &nums) {
        int n = nums.size();
        sums.resize(n + 1);
        for (int i = 0; i < n; i++) {
            sums[i + 1] = sums[i] + nums[i];
        }
    }

    int sumRange(int left, int right) {
        return sums[j + 1] - sums[i];
    }
};
```

### 矩阵的前缀和

[304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

```C++
class NumMatrix {
private:
    vector<vector<int> > sums;
public:
    NumMatrix(vector<vector<int> > &matrix) {
        sums.resize(matrix.size() + 1, vector<int>(matrix[0].size() + 1, 0));
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size(); j++) {
                sums[i + 1][j + 1] = sums[i + 1][j] + sums[i][j + 1] - sums[i][j] + matrix[i][j];
            }
        }
    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        return sums[row2 + 1][col2 + 1] - sums[row1][col2 + 1] - sums[row2 + 1][col1] + sums[row1][col1];
    }
};
```

[1314. 矩阵区域和](https://leetcode.cn/problems/matrix-block-sum/)

```
vector<vector<int> > matrixBlockSum(vector<vector<int> > &mat, int k) {
    vector<vector<int> > sums(mat.size(), vector<int>(mat[0].size(), 0));
    for (int i = 0; i < mat.size(); i++) {
        for (int j = 0; j < mat[i].size(); j++) {
            int sum = 0;
            for (int m = i - k; m <= i + k; m++) {
                if (m >= 0 && m < mat.size()) {
                    for (int n = j - k; n <= j + k; n++) {
                        if (n >= 0 && n < mat[m].size()) {
                            sum += mat[m][n];
                        }
                    }
                }
            }
            sums[i][j] = sum;
        }
    }
    return sums;
}
```

### 二叉树与前缀和

[1022. 从根到叶的二进制数之和](https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/)

```
int dfs(TreeNode *root, int sum) {
    if (root) {
        sum = sum * 2 + root->val;
        if (!root->left && !root->right) {
            return sum;
        } else if (root->left && root->right) {
            return dfs(root->left, sum) + dfs(root->right, sum);
        } else if (root->left) {
            return dfs(root->left, sum);
        } else {
            return dfs(root->right, sum);
        }
    } else {
        return 0;
    }
}

int sumRootToLeaf(TreeNode *root) {
    return dfs(root, 0);
}
```

[129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

```
int dfs(TreeNode *root, int sum) {
    if (root) {
        sum = sum * 10 + root->val;
        if (!root->left && !root->right) {
            return sum;
        } else if (root->left && root->right) {
            return dfs(root->left, sum) + dfs(root->right, sum);
        } else if (root->left) {
            return dfs(root->left, sum);
        } else {
            return dfs(root->right, sum);
        }
    } else {
        return 0;
    }
}

int sumNumbers(TreeNode *root) {
    return dfs(root, 0);
}
```

[112. 路径总和](https://leetcode.cn/problems/path-sum/)

```
bool hasPathSum(TreeNode *root, int targetSum) {
    if (root) {
        if (!root->left && !root->right && targetSum == root->val) {
            return true;
        }
        return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);
    } else {
        return false;
    }
}
```

[113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

```
void dfs(TreeNode *root, int targetSum, vector<int> &path, vector<vector<int> > &result) {
    if (root) {
        path.emplace_back(root->val);
        if (!root->left && !root->right && targetSum == root->val) {
            result.push_back(path);
        }
        dfs(root->left, targetSum - root->val, path, result);
        dfs(root->right, targetSum - root->val, path, result);
        path.pop_back();
    }
}

vector<vector<int> > pathSum(TreeNode *root, int targetSum) {
    vector<vector<int> > result;
    vector<int> path;
    dfs(root, targetSum, path, result);
    return result;
}
```

[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

```
long long travel(TreeNode *root, long long sum) {
    if (root) {
        if (sum == root->val) {
            return 1 + travel(root->left, sum - root->val) + travel(root->right, sum - root->val);
        } else {
            return travel(root->left, sum - root->val) + travel(root->right, sum - root->val);
        }
    } else {
        return 0;
    }
}

int pathSum(TreeNode *root, int sum) {
    return root ? travel(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum) : 0;
}
```

# 算法进阶

## 数据范围与时间复杂度

| 数据范围      | 允许的时间复杂度    | 适用算法**举例**                         |
| ------------- | ------------------- | ---------------------------------------- |
| $n≤10$        | $O(n!)$ 或 $O(C^n)$ | 回溯、暴力搜索                           |
| $n≤20$        | $O(2^n)$            | 状态压缩 DP                              |
| $n≤40$        | $O(n^{n/2})$        | 折半枚举                                 |
| $n≤10^2$    | $O(n^3)$            | 三重循环的 DP、Floyd                     |
| $n≤10^3$    | $O(n^2)$            | 二重循环的 DP、背包                      |
| $n≤10^5$    | $O(nlogn)$        | 大多数题目都是这个范围，所以各类算法都有 |
| $n≤10^6$    | $O(n)$              | 线性 DP、滑动窗口                        |
| $n≤10^9$    | $O(n)$              | 判断质数                                 |
| $n≤10^{18}$ | $O(logn)$ 或 $O(1)$   | 二分、快速幂、数学公式                   |

## 滑动窗口

### 定长滑动窗口

- 符合条件时收缩窗口
- 窗口仅收缩一次
- 收缩窗口时（即符合条件时）计算结果

[1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)

```
int maxVowels(string s, int k) {
    int result = 0;
    unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};
    int count = 0;
    int left = 0;
    int right = 0;
    while (right < s.length()) {
        if (vowels.contains(s[right])) {
            count++;
        }
        if (right - left + 1 == k) {
            result = max(result, count);
            if (vowels.contains(s[left])) {
                count--;
            }
            left++;
        }
        right++;
    }
    return result;
}
```

[643. 子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/)

```
double findMaxAverage(vector<int> &nums, int k) {
    double result = INT_MIN;
    double sum = 0;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        sum += nums[right];
        if (right - left + 1 == k) {
            result = max(result, sum / k);
            sum -= nums[left];
            left++;
        }
        right++;
    }
    return result;
}
```

[1343. 大小为 K 且平均值大于等于阈值的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/)

```
int numOfSubarrays(vector<int> &arr, int k, int threshold) {
    int result = 0;
    int sum = 0;
    int left = 0;
    int right = 0;
    while (right < arr.size()) {
        sum += arr[right];
        if (right - left + 1 == k) {
            if (sum * 1.0 / k >= threshold) {
                result += 1;
            }
            sum -= arr[left];
            left++;
        }
        right++;
    }
    return result;
}
```

[2090. 半径为 k 的子数组平均值](https://leetcode.cn/problems/k-radius-subarray-averages/)

```
vector<int> getAverages(vector<int> &nums, int k) {
    if (k == 0) {
        return nums;
    }

    vector<int> result(nums.size(), -1);
    if (nums.size() <= 2 * k) {
        return result;
    }
    unsigned long long sum = 0;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        sum += nums[right];
        if (right - left + 1 == 2 * k + 1) {
            result[right - k] = sum / (2 * k + 1);
            sum -= nums[left];
            left++;
        }
        right++;
    }
    return result;
}
```

[2461. 长度为 K 子数组中的最大和](https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/)

```
long long maximumSubarraySum(vector<int> &nums, int k) {
    unsigned long long result = 0;
    unsigned long long sum = 0;
    unordered_map<int, int> window;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        sum += nums[right];
        window[nums[right]]++;
        if (right - left + 1 == k) {
            if (window.size() == k) {
                result = max(result, sum);
            }
            sum -= nums[left];
            window[nums[left]]--;
            if (window[nums[left]] == 0) {
                window.erase(nums[left]);
            }
            left++;
        }
        right++;
    }
    return result;
}
```

[2379. 得到 K 个黑块的最少涂色次数](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/)

```
int minimumRecolors(string blocks, int k) {
    int result = INT_MAX;
    unordered_map<char, int> window;
    int left = 0;
    int right = 0;
    while (right < blocks.size()) {
        window[blocks[right]]++;
        if (right - left + 1 == k) {
            result = min(result, window['W']);
            window[blocks[left]]--;
            left++;
        }
        right++;
    }
    return result;
}
```

[1423. 可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)

```
int maxScore(vector<int> &cardPoints, int k) {
    if (cardPoints.size() == k) {
        return accumulate(cardPoints.begin(), cardPoints.end(), 0);
    }
    int result = INT_MAX;
    int sum = 0;
    int left = 0;
    int right = 0;
    while (right < cardPoints.size()) {
        sum += cardPoints[right];
        if (right - left + 1 == cardPoints.size() - k) {
            result = min(result, sum);
            sum -= cardPoints[left];
            left++;
        }
        right++;
    }
    return accumulate(cardPoints.begin(), cardPoints.end(), 0) - result;
}
```

[2841. 几乎唯一子数组的最大和](https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/)

```
long long maxSum(vector<int> &nums, int m, int k) {
    unsigned long long result = 0;
    unsigned long long sum = 0;
    unordered_map<int, int> window;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        sum += nums[right];
        window[nums[right]]++;
        if (right - left + 1 == k) {
            if (window.size() >= m) {
                result = max(result, sum);
            }
            sum -= nums[left];
            window[nums[left]]--;
            if (window[nums[left]] == 0) {
                window.erase(nums[left]);
            }
            left++;
        }
        right++;
    }
    return result;
}
```

### 不定长滑动窗口

#### 越短越合法/求最长/求最大

- 不符合条件时收缩窗口
- 收缩窗口完毕后（即符合条件时）计算结果

[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

```
int lengthOfLongestSubstring(string s) {
    int result = 0;
    unordered_map<char, int> window;
    int left = 0;
    int right = 0;
    while (right < s.length()) {
        window[s[right]]++;
        while (window.size() < right - left + 1) {
            window[s[left]]--;
            if (window[s[left]] == 0) {
                window.erase(s[left]);
            }
            left++;
        }
        result = max(result, right - left + 1);
        right++;
    }
    return result;
}
```

[3090. 每个字符最多出现两次的最长子字符串](https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/)

```
int maximumLengthSubstring(string s) {
    int result = 0;
    unordered_map<char, int> window;
    int left = 0;
    int right = 0;
    while (right < s.length()) {
    	window[s[right]]++;
        while (window[s[right]] > 2) {
            window[s[left]]--;
            left++;
        }
        result = max(result, right - left + 1);
        right++;
    }
    return result;
}
```

[1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/)

```
int longestSubarray(vector<int> &nums) {
    int result = 0;
    unordered_map<int, int> window;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        window[nums[right]]++;
        while (window[0] == 2) {
            window[nums[left]]--;
            left++;
        }
        result = max(result, right - left);
        right++;
    }
    return result;
}
```

[3634. 使数组平衡的最少移除数目](https://leetcode.cn/problems/minimum-removals-to-balance-array/)

```
int minRemoval(vector<int> &nums, int k) {
    sort(nums.begin(), nums.end());
    int result = 0;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        while (1LL * nums[left] * k < nums[right]) {
            left++;
        }
        result = max(result, right - left + 1);
        right++;
    }
    return nums.size() - result;
}
```

[1208. 尽可能使字符串相等](https://leetcode.cn/problems/get-equal-substrings-within-budget/)

```
int equalSubstring(string s, string t, int maxCost) {
    int result = 0;
    int cost = 0;
    int left = 0;
    int right = 0;
    while (right < s.length()) {
        cost += abs(s[right] - t[right]);
        while (cost > maxCost) {
            cost -= abs(s[left] - t[left]);
            left++;
        }
        result = max(result, right - left + 1);
        right++;
    }
    return result;
}
```

[904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

```
int totalFruit(vector<int> &fruits) {
    int result = 0;
    unordered_map<int, int> window;
    int left = 0;
    int right = 0;
    while (right < fruits.size()) {
        window[fruits[right]]++;
        while (window.size() > 2) {
            window[fruits[left]]--;
            if (window[fruits[left]] == 0) {
                window.erase(fruits[left]);
            }
            left++;
        }
        result = max(result, right - left + 1);
        right++;
    }
    return result;
}
```

[1695. 删除子数组的最大得分](https://leetcode.cn/problems/maximum-erasure-value/)

```
int maximumUniqueSubarray(vector<int> &nums) {
    int result = 0;
    int sum = 0;
    unordered_map<int, int> window;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        sum += nums[right];
        window[nums[right]]++;
        while (window.size() != right - left + 1) {
            sum -= nums[left];
            window[nums[left]]--;
            if (window[nums[left]] == 0) {
                window.erase(nums[left]);
            }
            left++;
        }
        result = max(result, sum);
        right++;
    }
    return result;
}
```

[2958. 最多 K 个重复元素的最长子数组](https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/)

```
int maxSubarrayLength(vector<int> &nums, int k) {
    int result = 0;
    unordered_map<int, int> window;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        window[nums[right]]++;
        while (window[nums[right]] > k) {
            window[nums[left]]--;
            left++;
        }
        result = max(result, right - left + 1);
        right++;
    }
    return result;
}
```

[1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

```
int longestOnes(vector<int> &nums, int k) {
    int result = 0;
    unordered_map<int, int> window;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        window[nums[right]]++;
        while (window[0] > k) {
            window[nums[left]]--;
            left++;
        }
        result = max(result, right - left + 1);
        right++;
    }
    return result;
}
```

[2024. 考试的最大困扰度](https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/)

```
int maxConsecutiveAnswers(string answerKey, int k, char c) {
    int result = 0;
    unordered_map<char, int> window;
    int left = 0;
    int right = 0;
    while (right < answerKey.size()) {
        window[answerKey[right]]++;
        while (window[c] > k) {
            window[answerKey[left]]--;
            if (window[answerKey[left]] == 0) {
                window.erase(answerKey[left]);
            }
            left++;
        }
        result = max(result, right - left + 1);
        right++;
    }
    return result;
}

int maxConsecutiveAnswers(string answerKey, int k) {
    return max(maxConsecutiveAnswers(answerKey, k, 'T'), maxConsecutiveAnswers(answerKey, k, 'F'));
}
```

[1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

```
int minOperations(vector<int> &nums, int x) {
    int s = accumulate(nums.begin(), nums.end(), 0);
    if (s < x) {
        return -1;
    }
    int result = INT_MAX;
    int sum = 0;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        sum += nums[right];
        while (sum > s - x) {
            sum -= nums[left];
            left++;
        }
        if (sum == s - x) {
            result = min(result, static_cast<int>(nums.size()) - (right - left + 1));
        }
        right++;
    }
    return result == INT_MAX ? -1 : result;
}
```

#### 越长越合法/求最短/求最小

- 符合条件时收缩窗口
- 收缩窗口时（即符合条件时）计算结果

[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```
int minSubArrayLen(int target, vector<int> &nums) {
    int result = INT_MAX;
    int sum = 0;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        sum += nums[right];
        while (sum >= target) {
            result = min(result, right - left + 1);
            sum -= nums[left];
            left++;
        }
        right++;
    }
    return result == INT_MAX ? 0 : result;
}
```

[2904. 最短且字典序最小的美丽子字符串](https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/)

```
string shortestBeautifulSubstring(string s, int k) {
    string result;
    unordered_map<char, int> window;
    int length = INT_MAX;
    int left = 0;
    int right = 0;
    while (right < s.length()) {
        window[s[right]]++;
        while (window['1'] == k) {
            if (length > right - left + 1) {
                length = right - left + 1;
                result = s.substr(left, right - left + 1);
            } else if (length == right - left + 1) {
                result = min(result, s.substr(left, right - left + 1));
            }
            window[s[left]]--;
            left++;
        }
        right++;
    }
    return result;
}
```

[1234. 替换子串得到平衡字符串](https://leetcode.cn/problems/replace-the-substring-for-balanced-string/)

```
int balancedString(string s) {
    unordered_map<char, int> window;
    for (int i = 0; i < s.length(); i++) {
        window[s[i]]++;
    }

    int m = s.length() / 4;
    if (window['Q'] == m && window['W'] == m && window['E'] == m && window['R'] == m) {
        return 0;
    }

    int result = INT_MAX;
    int left = 0;
    int right = 0;
    while (right < s.length()) {
        window[s[right]]--;
        while (window['Q'] <= m && window['W'] <= m && window['E'] <= m && window['R'] <= m) {
            result = min(result, right - left + 1);
            window[s[left]]++;
            left++;
        }
        right++;
    }
    return result;
}
```

[2875. 无限数组的最短子数组](https://leetcode.cn/problems/minimum-size-subarray-in-infinite-array/)

```
int minSizeSubarray(vector<int> &nums, int target) {
    unsigned long long s = accumulate(nums.begin(), nums.end(), 0LL);
    unsigned long long n = target / s;
    unsigned long long t = target % s;
    if (t == 0) {
        return n * nums.size();
    }

    unsigned long long result = LONG_LONG_MAX;
    unsigned long long sum = 0;
    int left = 0;
    int right = 0;
    while (right < 2 * nums.size()) {
        sum += nums[right % nums.size()];
        while (sum > t) {
            sum -= nums[left % nums.size()];
            left++;
        }
        if (sum == t) {
            result = min(result, static_cast<unsigned long long>(right - left + 1));
        }
        right++;
    }
    return result == LONG_LONG_MAX ? -1 : static_cast<int>(result + n * nums.size());
}
```

[632. 最小区间](https://leetcode.cn/problems/smallest-range-covering-elements-from-k-lists/)

```
vector<int> smallestRange(vector<vector<int> > &nums) {
    vector<pair<int, int> > numbers;
    for (int i = 0; i < nums.size(); i++) {
        for (int j = 0; j < nums[i].size(); j++) {
            numbers.push_back(make_pair(nums[i][j], i));
        }
    }
    sort(numbers.begin(), numbers.end(), [](const auto &a, const auto &b) { return a.first < b.first; });

    vector<int> result = {0,INT_MAX};
    unordered_map<int, int> window;
    int left = 0;
    int right = 0;
    while (right < numbers.size()) {
        window[numbers[right].second]++;
        while (window.size() == nums.size()) {
            if (result[1] - result[0] > numbers[right].first - numbers[left].first ||
                (result[1] - result[0] == numbers[right].first - numbers[left].first && result[0] > numbers[left].first)
            ) {
                result[0] = numbers[left].first;
                result[1] = numbers[right].first;
            }
            window[numbers[left].second]--;
            if (window[numbers[left].second] == 0) {
                window.erase(numbers[left].second);
            }
            left++;
        }
        right++;
    }
    return result;
}
```

#### 求子数组个数

##### 越短越合法

- 不符合条件时收缩窗口
- 收缩窗口完毕后（即符合条件时）计算结果
- 满足条件的子数组的个数为`right - left + 1`

[713. 乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/)

```
int numSubarrayProductLessThanK(vector<int> &nums, int k) {
    if (k <= 1) {
        return 0;
    }
    int result = 0;
    int product = 1;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        product *= nums[right];
        while (product >= k) {
            product /= nums[left];
            left++;
        }
        result += right - left + 1;
        right++;
    }
    return result;
}
```

[3258. 统计满足 K 约束的子字符串数量 I](https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/)

```
int countKConstraintSubstrings(string s, int k) {
    int result = 0;
    unordered_map<char, int> window;
    int left = 0;
    int right = 0;
    while (right < s.size()) {
        window[s[right]]++;
        while (window['0'] > k && window['1'] > k) {
            window[s[left]]--;
            left++;
        }
        result += right - left + 1;
        right++;
    }
    return result;
}
```

[2302. 统计得分小于 K 的子数组数目](https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/)

```
long long countSubarrays(vector<int> &nums, long long k) {
    long long result = 0;
    long long sum = 0;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        sum += nums[right];
        while (sum * (right - left + 1) >= k) {
            sum -= nums[left];
            left++;
        }
        result += right - left + 1;
        right++;
    }
    return result;
}
```

[2762. 不间断子数组](https://leetcode.cn/problems/continuous-subarrays/)

```
long long continuousSubarrays(vector<int> &nums) {
    long long result = 0;
    multiset<int> window;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        window.insert(nums[right]);
        while (*window.rbegin() - *window.begin() > 2) {
            window.erase(window.find(nums[left]));
            left++;
        }
        result += right - left + 1;
        right++;
    }
    return result;
}
```

[LCP 68. 美观的花束](https://leetcode.cn/problems/1GxJYY/)

```
int beautifulBouquet(vector<int> &flowers, int cnt) {
    int result = 0;
    int mod = 1e9 + 7;
    unordered_map<int, int> window;
    int left = 0;
    int right = 0;
    while (right < flowers.size()) {
        window[flowers[right]]++;
        while (window[flowers[right]] > cnt) {
            window[flowers[left]]--;
            left++;
        }
        result += right - left + 1;
        result %= mod;
        right++;
    }
    return result;
}
```

##### 越长越合法

- 符合条件时收缩窗口
- 收缩窗口时（即符合条件时）计算结果，当前状态下满足条件的子数组的个数为`n - right`
- 收缩窗口完毕后（即不符合条件时）计算结果，当前状态下满足条件的子数组的个数为`left`

[1358. 包含所有三种字符的子字符串数目](https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/)

```
int numberOfSubstrings(string s) {
    int result = 0;
    unordered_map<char, int> window;
    int left = 0;
    int right = 0;
    while (right < s.length()) {
        window[s[right]]++;
        while (window['a'] > 0 && window['b'] > 0 && window['c'] > 0) {
        	// result += s.length() - right;
            window[s[left]]--;
            left++;
        }
        result += left;
        right++;
    }
    return result;
}
```

[2962. 统计最大元素出现至少 K 次的子数组](https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/)

```
long long countSubarrays(vector<int> &nums, int k) {
    long long result = 0;
    int maximum = *max_element(nums.begin(), nums.end());
    int count = 0;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        if (nums[right] == maximum) {
            count++;
        }
        while (count >= k) {
            // result += nums.size() - right;
            if (nums[left] == maximum) {
                count--;
            }
            left++;
        }
        result += left;
        right++;
    }
    return result;
}
```

[3325. 字符至少出现 K 次的子字符串 I](https://leetcode.cn/problems/count-substrings-with-k-frequency-characters-i/)

```
int numberOfSubstrings(string s, int k) {
    int result = 0;
    unordered_set<char> set;
    for (int i = 0; i < s.length(); i++) {
        set.insert(s[i]);
    }
    unordered_map<char, int> window;
    int left = 0;
    int right = 0;
    while (right < s.length()) {
        window[s[right]]++;
        while (window[s[right]] >= k) {
            // result += s.length() - right;
            window[s[left]]--;
            if (window[s[left]] == 0) {
                window.erase(s[left]);
            }
            left++;
        }
        result += left;
        right++;
    }
    return result;
}
```

[2799. 统计完全子数组的数目](https://leetcode.cn/problems/count-complete-subarrays-in-an-array/)

```
int countCompleteSubarrays(vector<int> &nums) {
    int result = 0;
    unordered_set<int> set(nums.begin(), nums.end());
    unordered_map<int, int> window;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        window[nums[right]]++;
        while (window.size() == set.size()) {
            // result += nums.size() - right;
            window[nums[left]]--;
            if (window[nums[left]] == 0) {
                window.erase(nums[left]);
            }
            left++;
        }
        result += left;
        right++;
    }
    return result;
}
```

[2537. 统计好子数组的数目](https://leetcode.cn/problems/count-the-number-of-good-subarrays/)

```
long long countGood(vector<int> &nums, int k) {
    long long result = 0;
    unordered_map<int, int> window;
    int count = 0;
    int left = 0;
    int right = 0;
    while (right < nums.size()) {
        count += window[nums[right]];
        window[nums[right]]++;
        while (count >= k) {
            // result += nums.size() - right;
            window[nums[left]]--;
            count -= window[nums[left]];
            left++;
        }
        result += left;
        right++;
    }
    return result;
}
```

[3298. 统计重新排列后包含另一个字符串的子字符串数目 II](https://leetcode.cn/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-ii/)

```
long long validSubstringCount(string word1, string word2) {
    long long result = 0;
    unordered_map<char, int> need;
    for (const auto &c: word2) {
        need[c]++;
    }
    unordered_map<char, int> window;
    int valid = 0;
    int left = 0;
    int right = 0;
    while (right < word1.length()) {
        window[word1[right]]++;
        if (need.contains(word1[right]) && need[word1[right]] == window[word1[right]]) {
            valid++;
        }
        while (valid == need.size()) {
            // result += word1.length() - right;
            if (need.contains(word1[left]) && need[word1[left]] == window[word1[left]]) {
                valid--;
            }
            window[word1[left]]--;
            left++;
        }
        result += left;
        right++;
    }
    return result;
}
```

##### 恰好合法

- 题目等价于`等于K的数量=大于等于K的数量-大于K的数量=大于等于K的数量-大于等于K+1的数量`
- 符合条件时收缩窗口
- 收缩窗口时（即符合条件时）计算结果，当前状态下满足条件的子数组的个数为`n - right`
- 收缩窗口完毕后（即不符合条件时）计算结果，当前状态下满足条件的子数组的个数为`left`

[930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/)

```
int numSubarraysWithSum(vector<int> &nums, int goal) {
    const auto slidingWindow = [&](vector<int> &nums, int goal) -> int {
        int result = 0;
        int sum = 0;
        int left = 0;
        int right = 0;
        while (right < nums.size()) {
            sum += nums[right];
            while (sum >= goal && left <= right) {
                // result += nums.size() - right;
                sum -= nums[left];
                left++;
            }
            result += left;
            right++;
        }
        return result;
    };
    return slidingWindow(nums, goal) - slidingWindow(nums, goal + 1);
}
```

[1248. 统计「优美子数组」](https://leetcode.cn/problems/count-number-of-nice-subarrays/)

```
int numberOfSubarrays(vector<int> &nums, int k) {
    const auto slidingWindow = [&](vector<int> &nums, int k) -> int {
        int result = 0;
        int count = 0;
        int left = 0;
        int right = 0;
        while (right < nums.size()) {
            count += nums[right] % 2;
            while (count == k) {
                // result += nums.size() - right;
                count -= nums[left] % 2;
                left++;
            }
            result += left;
            right++;
        }
        return result;
    };
    return slidingWindow(nums, k) - slidingWindow(nums, k + 1);
}
```

[3306. 元音辅音字符串计数 II](https://leetcode.cn/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/)

```
long long countOfSubstrings(string word, int k) {
    const auto slidingWindow = [&](string word, int k) -> long long {
        long long result = 0;
        unordered_map<char, int> vowels;
        int consonants = 0;
        int left = 0;
        int right = 0;
        while (right < word.length()) {
            if (word[right] == 'a' || word[right] == 'e' || word[right] == 'i' || word[right] == 'o' ||
                word[right] == 'u') {
                vowels[word[right]]++;
            } else {
                consonants++;
            }
            while (vowels['a'] > 0 && vowels['e'] > 0 && vowels['i'] > 0 && vowels['o'] > 0 && vowels['u'] > 0 &&
                   consonants >= k) {
                // result += word.length() - right;
                if (word[left] == 'a' || word[left] == 'e' || word[left] == 'i' || word[left] == 'o' ||
                    word[left] == 'u') {
                    vowels[word[left]]--;
                } else {
                    consonants--;
                }
                left++;
            }
            result += left;
            right++;
        }
        return result;
    };
    return slidingWindow(word, k) - slidingWindow(word, k + 1);
}
```

[992. K 个不同整数的子数组](https://leetcode.cn/problems/subarrays-with-k-different-integers/)

```
int subarraysWithKDistinct(vector<int> &nums, int k) {
    const auto slidingWindow = [&](vector<int> &nums, int k) -> int {
        int result = 0;
        unordered_map<int, int> window;
        int left = 0;
        int right = 0;
        while (right < nums.size()) {
            window[nums[right]]++;
            while (window.size() >= k) {
                // result += nums.size() - right;
                window[nums[left]]--;
                if (window[nums[left]] == 0) {
                    window.erase(nums[left]);
                }
                left++;
            }
            result += left;
            right++;
        }
        return result;
    };
    return slidingWindow(nums, k) - slidingWindow(nums, k + 1);
}
```

## 双指针

#### 单序列

##### 相向双指针

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

```
void reverseString(vector<char> &s) {
    int left = 0;
    int right = s.size() - 1;
    while (left < right) {
        swap(s[left], s[right]);
        left++;
        right--;
    }
}
```

[3643. 垂直翻转子矩阵](https://leetcode.cn/problems/flip-square-submatrix-vertically/)

```
vector<vector<int>> reverseSubmatrix(vector<vector<int>> &grid, int x, int y, int k) {
    for (int i = 0; i < k / 2; i++) {
        for (int j = 0; j < k; j++) {
            swap(grid[x + i][y + j], grid[x + k - 1 - i][y + j]);
        }
    }
    return grid;
}
```

[125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)

```
bool isPalindrome(string s) {
    string str = "";
    for (const auto &c: s) {
        if (isalpha(c) || isdigit(c)) {
            str += tolower(c);
        }
    }

    int left = 0;
    int right = str.length() - 1;
    while (left < right && str[left] == str[right]) {
        left++;
        right--;
    }
    return left >= right;
}
```

[1750. 删除字符串两端相同字符后的最短长度](https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/)

```
int minimumLength(string s) {
    int result = 0;
    int left = 0;
    int right = s.length() - 1;
    while (left < right && s[left] == s[right]) {
        while (left < right && s[left] == s[left + 1]) {
            result++;
            left++;
        }
        while (left < right && s[right] == s[right - 1]) {
            result++;
            right--;
        }
        result += 2;
        left++;
        right--;
    }
    return s.length() - (left <= right ? result : result - 1);
}
```

[2105. 给植物浇水 II](https://leetcode.cn/problems/watering-plants-ii/)

```
int minimumRefill(vector<int> &plants, int capacityA, int capacityB) {
    int result = 0;
    int left = 0;
    int right = plants.size() - 1;
    int ca = capacityA;
    int cb = capacityB;
    while (left <= right) {
        if (left < right) {
            if (ca >= plants[left]) {
                ca -= plants[left];
            } else {
                ca = capacityA - plants[left];
                result++;
            }
            if (cb >= plants[right]) {
                cb -= plants[right];
            } else {
                cb = capacityB - plants[right];
                result++;
            }
        } else {
            if (ca < plants[left] && cb < plants[right]) {
                result++;
            }
        }
        left++;
        right--;
    }
    return result;
}
```

[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

```
vector<int> sortedSquares(vector<int> &nums) {
    vector<int> result(nums.size());
    int index = nums.size() - 1;
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int l = nums[left] * nums[left];
        int r = nums[right] * nums[right];
        if (l >= r) {
            result[index] = l;
            left++;
        } else {
            result[index] = r;
            right--;
        }
        index--;
    }
    return result;
}
```

[658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/)

```
vector<int> findClosestElements(vector<int> &arr, int k, int x) {
    int left = 0;
    int right = arr.size() - 1;
    while (left <= right - k) {
        if (abs(arr[left] - x) <= abs(arr[right] - x)) {
            right--;
        } else {
            left++;
        }
    }
    return vector<int>(arr.begin() + left, arr.begin() + left + k);
}
```

[1471. 数组中的 k 个最强值](https://leetcode.cn/problems/the-k-strongest-values-in-an-array/)

```
vector<int> getStrongest(vector<int> &arr, int k) {
    sort(arr.begin(), arr.end());
    vector<int> result(k);
    int index = 0;
    int m = arr.size() % 2 ? arr[arr.size() / 2] : (arr[(arr.size() - 1) / 2]);
    int left = 0;
    int right = arr.size() - 1;
    while (left <= right && k--) {
        if (abs(arr[left] - m) == abs(arr[right] - m)) {
            if (arr[left] > arr[right]) {
                result[index] = arr[left];
                left++;
            } else {
                result[index] = arr[right];
                right--;
            }
        } else if (abs(arr[left] - m) > abs(arr[right] - m)) {
            result[index] = arr[left];
            left++;
        } else {
            result[index] = arr[right];
            right--;
        }
        index++;
    }
    return result;
}
```

[167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

```
vector<int> twoSum(vector<int> &numbers, int target) {
    int left = 0;
    int right = numbers.size() - 1;
    while (left < right) {
        int sum = numbers[left] + numbers[right];
        if (sum == target) {
            return {left + 1, right + 1};
        } else if (sum > target) {
            right--;
        } else {
            left++;
        }
    }
    return {0, 0};
}
```

[633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/)

```
bool judgeSquareSum(int c) {
    long long left = 0;
    long long right = sqrt(c);
    while (left <= right) {
        long long sum = left * left + right * right;
        if (sum == c) {
            return true;
        } else if (sum > c) {
            right--;
        } else {
            left++;
        }
    }
    return false;
}
```

[2824. 统计和小于目标的下标对数目](https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/)

```
int countPairs(vector<int> &nums, int target) {
    sort(nums.begin(), nums.end());
    int result = 0;
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        if (nums[left] + nums[right] < target) {
            result += right - left;
            left++;
        } else {
            right--;
        }
    }
    return result;
}
```

[2563. 统计公平数对的数目](https://leetcode.cn/problems/count-the-number-of-fair-pairs/)

```
long long countFairPairs(vector<int> &nums, int lower, int upper) {
    sort(nums.begin(), nums.end());
    long long result = 0;
    for (int i = 0; i < nums.size(); i++) {
        auto left =
                lower_bound(nums.begin(), nums.begin() + i, lower - nums[i]);
        auto right =
                upper_bound(nums.begin(), nums.begin() + i, upper - nums[i]);

        result += right - left;
    }
    return result;
}
```

[15. 三数之和](https://leetcode.cn/problems/3sum/)

```
vector<vector<int> > threeSum(vector<int> &nums) {
    sort(nums.begin(), nums.end());
    vector<vector<int> > result;
    for (int i = 0; i < nums.size() - 2; i++) {
        if (i == 0 || nums[i] != nums[i - 1]) {
            int left = i + 1;
            int right = nums.size() - 1;
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if (sum == 0) {
                    result.push_back({nums[i], nums[left], nums[right]});
                    while (left < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    left++;
                    while (left < right && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    right--;
                } else if (sum > 0) {
                    right--;
                } else {
                    left++;
                }
            }
        }
    }
    return result;
}
```

[16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)

```
int threeSumClosest(vector<int> &nums, int target) {
    sort(nums.begin(), nums.end());
    int result = 0;
    int diff = INT_MAX;
    for (int i = 0; i < nums.size() - 2; i++) {
        int left = i + 1;
        int right = nums.size() - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum == target) {
                return sum;
            } else if (sum > target) {
                if (sum - target < diff) {
                    diff = sum - target;
                    result = sum;
                }
                right--;
            } else {
                if (target - sum < diff) {
                    diff = target - sum;
                    result = sum;
                }
                left++;
            }
        }
    }
    return result;
}
```

[18. 四数之和](https://leetcode.cn/problems/4sum/)

```
vector<vector<int> > fourSum(vector<int> &nums, int target) {
    vector<vector<int> > result;
    if (nums.size() < 4) {
        return result;
    }
    sort(nums.begin(), nums.end());
    for (int i = 0; i < nums.size() - 3; i++) {
        if (i == 0 || nums[i] != nums[i - 1]) {
            for (int j = i + 1; j < nums.size() - 2; j++) {
                if (j == i + 1 || nums[j] != nums[j - 1]) {
                    int left = j + 1;
                    int right = nums.size() - 1;
                    while (left < right) {
                        long long sum = static_cast<long long>(nums[i]) + static_cast<long long>(nums[j]) +
                                        static_cast<long long>(nums[left]) + static_cast<long long>(nums[right]);
                        if (sum == target) {
                            result.push_back({nums[i], nums[j], nums[left], nums[right]});
                            while (left < right && nums[left] == nums[left + 1]) {
                                left++;
                            }
                            left++;
                            while (left < right && nums[right] == nums[right - 1]) {
                                right--;
                            }
                            right--;
                        } else if (sum > target) {
                            right--;
                        } else {
                            left++;
                        }
                    }
                }
            }
        }
    }
    return result;
}
```

[611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)

```
int triangleNumber(vector<int> &nums) {
    sort(nums.begin(), nums.end());
    int result = 0;
    for (int k = 2; k < nums.size(); k++) {
        int i = 0;
        int j = k - 1;
        while (i < j) {
            if (nums[i] + nums[j] > nums[k]) {
                result += j - i;
                j--;
            } else {
                i++;
            }
        }
    }
    return result;
}
```

[1577. 数的平方等于两数乘积的方法数](https://leetcode.cn/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/)

```
int countTriplets(vector<int> &nums1, vector<int> &nums2) {
    int result = 0;
    for (int i = 0; i < nums1.size(); i++) {
        int left = 0;
        int right = nums2.size() - 1;
        while (left < right) {
            long long power = static_cast<long long>(nums1[i]) * static_cast<long long>(nums1[i]);
            long long target = static_cast<long long>(nums2[left]) * static_cast<long long>(nums2[right]);
            if (power == target) {
                if (nums2[left] == nums2[right]) {
                    result += (right - left + 1) * (right - left) / 2;
                    break;
                } else {
                    int c1 = 1;
                    while (left < right && nums2[left] == nums2[left + 1]) {
                        c1++;
                        left++;
                    }
                    left++;
                    int c2 = 1;
                    while (left < right && nums2[right] == nums2[right - 1]) {
                        c2++;
                        right--;
                    }
                    right--;
                    result += c1 * c2;
                }
            } else if (power < target) {
                right--;
            } else {
                left++;
            }
        }
    }
    return result;
}

int numTriplets(vector<int> &nums1, vector<int> &nums2) {
    sort(nums1.begin(), nums1.end());
    sort(nums2.begin(), nums2.end());
    return countTriplets(nums1, nums2) + countTriplets(nums2, nums1);
}
```

[923. 多重三数之和](https://leetcode.cn/problems/3sum-with-multiplicity/)

```
int threeSumMulti(vector<int> &arr, int target) {
    sort(arr.begin(), arr.end());
    int result = 0;
    for (int i = 0; i < arr.size() - 2; i++) {
        int left = i + 1;
        int right = arr.size() - 1;
        while (left < right) {
            int sum = arr[i] + arr[left] + arr[right];
            if (sum == target) {
                if (arr[left] == arr[right]) {
                    result += (right - left + 1) * (right - left) / 2;
                    result %= static_cast<int>(1e9 + 7);
                    break;
                } else {
                    int c1 = 1;
                    while (left < right && arr[left] == arr[left + 1]) {
                        c1++;
                        left++;
                    }
                    left++;
                    int c2 = 1;
                    while (left < right && arr[right] == arr[right - 1]) {
                        c2++;
                        right--;
                    }
                    right--;
                    result += c1 * c2;
                    result %= static_cast<int>(1e9 + 7);
                }
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
    }
    return result;
}
```

[948. 令牌放置](https://leetcode.cn/problems/bag-of-tokens/)

```
int bagOfTokensScore(vector<int> &tokens, int power) {
    sort(tokens.begin(), tokens.end());
    int result = 0;
    int score = 0;
    int left = 0;
    int right = tokens.size() - 1;
    while (left <= right) {
        if (power < tokens[left]) {
            if (score>=1) {
                power += tokens[right];
                score--;
                right--;
            }else {
                break;
            }
        } else {
            power -= tokens[left];
            score++;
            left++;
        }
        result = max(result, score);
    }
    return result;
}
```

[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

```
int maxArea(vector<int> &height) {
    int result = 0;
    int left = 0;
    int right = height.size() - 1;
    while (left < right) {
        int area = (right - left) * min(height[left], height[right]);
        result = max(result, area);
        if (height[left] > height[right]) {
            right--;
        } else {
            left++;
        }
    }
    return result;
}
```

[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

```
int trap(vector<int> &height) {
    int result = 0;
    int left = 0;
    int right = height.size() - 1;
    int maxl = 0;
    int maxr = 0;
    while (left < right) {
        maxl = max(maxl, height[left]);
        maxr = max(maxr, height[right]);
        if (height[left] < height[right]) {
            result += maxl - height[left];
            left++;
        } else {
            result += maxr - height[right];
            right--;
        }
    }
    return result;
}
```

[1616. 分割两个字符串得到回文串](https://leetcode.cn/problems/split-two-strings-to-make-palindrome/)

```
bool isPalindrome(string s, int left, int right) {
    while (left < right && s[left] == s[right]) {
        left++;
        right--;
    }
    return left >= right;
}

bool check(string a, string b) {
    int left = 0;
    int right = a.length() - 1;
    while (left < right && a[left] == b[right]) {
        left++;
        right--;
    }
    return isPalindrome(a, left, right) || isPalindrome(b, left, right);
}

bool checkPalindromeFormation(string a, string b) {
    return check(a, b) || check(b, a);
}
```

[1498. 满足条件的子序列数目](https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/)

```
long long qpow(long long x, long long n) {
    long long result = 1;
    while (n) {
        if (n & 1) {
            result *= x;
            result %= static_cast<long long>(1e9 + 7);
        }
        x *= x;
        x %= static_cast<long long>(1e9 + 7);
        n >>= 1;
    }
    return result;
}

int numSubseq(vector<int> &nums, int target) {
    sort(nums.begin(), nums.end());
    long long result = 0;
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int sum = nums[left] + nums[right];
        if (sum <= target) {
            result = (result + qpow(2, right - left)) % static_cast<long long>(1e9 + 7);
            left++;
        } else {
            right--;
        }
    }
    return static_cast<int>(result);
}
```

##### 同向双指针

[1574. 删除最短的子数组使剩余数组有序](https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted/)

```
int findLengthOfShortestSubarray(vector<int> &arr) {
    int right = arr.size() - 1;
    while (right > 0 && arr[right - 1] <= arr[right]) {
        right--;
    }

    if (right == 0) {
        return 0;
    }

    int result = right;
    int left = 0;
    while (left == 0 || arr[left - 1] <= arr[left]) {
        while (right < arr.size() && arr[left] > arr[right]) {
            right++;
        }
        result = min(result, right - left - 1);
        left++;
    }

    return result;
}
```

##### 背向双指针

[1793. 好子数组的最大分数](https://leetcode.cn/problems/maximum-score-of-a-good-subarray/)

```
int maximumScore(vector<int> &nums, int k) {
    int result = nums[k];
    int minimum = nums[k];
    int left = k;
    int right = k;
    while (left >= 0 || right < nums.size()) {
        if (left != 0 && right != nums.size() - 1) {
            if (nums[left - 1] >= nums[right + 1]) {
                minimum = min(minimum, nums[left - 1]);
                left--;
            } else {
                minimum = min(minimum, nums[right + 1]);
                right++;
            }
        } else if (left != 0) {
            minimum = min(minimum, nums[left - 1]);
            left--;
        } else if (right != nums.size() - 1) {
            minimum = min(minimum, nums[right + 1]);
            right++;
        } else {
            break;
        }
        result = max(result, minimum * (right - left + 1));
    }
    return result;
}
```

##### 原地修改

[27. 移除元素](https://leetcode.cn/problems/remove-element/)

```
int removeElement(vector<int> &nums, int val) {
    int i = 0;
    while (i < nums.size() && nums[i] != val) {
        i++;
    }
    int j = i;
    while (j < nums.size() && nums[j] == val) {
        j++;
    }
    while (j < nums.size()) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
        j++;
    }
    return i;
}
```

[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```
int removeDuplicates(vector<int> &nums) {
    if (nums.size() < 2) {
        return nums.size();
    }
    int index = 1;
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] != nums[index - 1]) {
            nums[index] = nums[i];
            index++;
        }
    }
    return index;
}
```

[80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)

```
int removeDuplicates(vector<int> &nums) {
    if (nums.size() <= 2) {
        return nums.size();
    }
    int index = 2;
    for (int i = 2; i < nums.size(); i++) {
        if (nums[i] != nums[index - 2]) {
            nums[index] = nums[i];
            index++;
        }
    }
    return index;
}
```

[283. 移动零](https://leetcode.cn/problems/move-zeroes/)

```
void moveZeroes(vector<int> &nums) {
    int index = 0;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] != 0) {
            nums[index] = nums[i];
            index++;
        }
    }
    for (int i = index; i < nums.size(); i++) {
        nums[i] = 0;
    }
}
```

[905. 按奇偶排序数组](https://leetcode.cn/problems/sort-array-by-parity/)

```
vector<int> sortArrayByParity(vector<int> &nums) {
    int i = 0;
    while (i < nums.size() && nums[i] % 2 == 0) {
        i++;
    }
    if (i == nums.size()) {
        return nums;
    }
    int j = i;
    while (j < nums.size()) {
        if (nums[j] % 2 == 0) {
            swap(nums[i], nums[j]);
            i++;
        }
        j++;
    }
    return nums;
}
```

[922. 按奇偶排序数组 II](https://leetcode.cn/problems/sort-array-by-parity-ii/)

```
vector<int> sortArrayByParityII(vector<int> &nums) {
    const auto nextOdd = [&](int index) {
        while (index < nums.size() && nums[index] % 2 == 0) {
            index++;
        }
        return index;
    };
    const auto nextEven = [&](int index) {
        while (index < nums.size() && nums[index] % 2 == 1) {
            index++;
        }
        return index;
    };
    for (int i = 0; i < nums.size(); i++) {
        if (i % 2 != nums[i] % 2) {
            if (nums[i] % 2 == 0) {
                swap(nums[i], nums[nextOdd(i)]);
            } else {
                swap(nums[i], nums[nextEven(i)]);
            }
        }
    }
    return nums;
}
```

[3467. 将数组按照奇偶性转化](https://leetcode.cn/problems/transform-array-by-parity/)

```
vector<int> transformArray(vector<int> &nums) {
    int count = 0;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] % 2 == 0) {
            count++;
        }
    }
    for (int i = 0; i < nums.size(); i++) {
        if (i < count) {
            nums[i] = 0;
        } else {
            nums[i] = 1;
        }
    }
    return nums;
}
```

[2460. 对数组执行操作](https://leetcode.cn/problems/apply-operations-to-an-array/)

```
vector<int> applyOperations(vector<int> &nums) {
    int count = 0;
    for (int i = 0; i < nums.size() - 1; i++) {
        if (nums[i] == 0) {
            count++;
        }
        if (nums[i] == nums[i + 1]) {
            nums[i] *= 2;
            nums[i + 1] = 0;
        }
    }
    if (!nums[nums.size() - 1]) {
        count++;
    }
    int index = 0;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i]) {
            nums[index] = nums[i];
            index++;
        }
    }
    for (int i = index; i < nums.size(); i++) {
        nums[i] = 0;
    }
    return nums;
}
```

[1089. 复写零](https://leetcode.cn/problems/duplicate-zeros/)

```
void duplicateZeros(vector<int> &arr) {
    int count = 0;
    int i = 0;
    for (i = 0; i < arr.size() - count; i++) {
        if (!arr[i]) {
            count++;
        }
    }

    if (!count) {
        return;
    }

    int index = arr.size() - 1;
    if (i > arr.size() - count) {
        arr[index] = 0;
        index--;
    }
    for (i = arr.size() - 1 - count; i >= 0; i--) {
        arr[index] = arr[i];
        index--;
        if (!arr[i]) {
            arr[index] = 0;
            index--;
        }
    }
}
```

#### 双序列

##### 双指针

[2109. 向字符串添加空格](https://leetcode.cn/problems/adding-spaces-to-a-string/)

```
string addSpaces(string s, vector<int> &spaces) {
    for (int i = 0; i < spaces.size(); i++) {
        spaces[i] = s.length() - spaces[i];
    }
    int left = s.length() - 1;
    int right = s.length() - 1 + spaces.size();
    int length = s.length();
    s += string(spaces.size(), ' ');
    for (int i = spaces.size() - 1; i >= 0;) {
        if (left != -1) {
            s[right] = s[left];
        }
        if (length - left - 1 == spaces[i]) {
            s[right] = ' ';
            i--;
            right--;
        } else {
            left--;
            right--;
        }
    }
    return s;
}
```

[2540. 最小公共值](https://leetcode.cn/problems/minimum-common-value/)

```
int getCommon(vector<int> &nums1, vector<int> &nums2) {
    int result = INT_MAX;
    int index1 = 0;
    int index2 = 0;
    while (index1 < nums1.size() && index2 < nums2.size()) {
        if (nums1[index1] == nums2[index2]) {
            result = min(result, nums1[index1]);
            index1++;
            index2++;
        } else if (nums1[index1] < nums2[index2]) {
            index1++;
        } else {
            index2++;
        }
    }

    return result == INT_MAX ? -1 : result;
}
```

[88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

```
void merge(vector<int> &nums1, int m, vector<int> &nums2, int n) {
    vector<int> nums(m + n);
    int i = 0;
    int j = 0;
    int k = 0;
    while (i < m || j < n) {
        if (i < m && j < n) {
            if (nums1[i] <= nums2[j]) {
                nums[k] = nums1[i];
                i++;
            } else {
                nums[k] = nums2[j];
                j++;
            }
        } else if (i < m) {
            nums[k] = nums1[i];
            i++;
        } else {
            nums[k] = nums2[j];
            j++;
        }

        k++;
    }
    nums1 = vector<int>(nums.begin(), nums.end());
}
```

[2570. 合并两个二维数组 - 求和法](https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values/)

```
vector<vector<int> > mergeArrays(vector<vector<int> > &nums1, vector<vector<int> > &nums2) {
    vector<vector<int> > result;
    int index1 = 0;
    int index2 = 0;
    while (index1 < nums1.size() || index2 < nums2.size()) {
        if (index1 < nums1.size() && index2 < nums2.size()) {
            if (nums1[index1][0] == nums2[index2][0]) {
                result.push_back({nums1[index1][0], nums1[index1][1] + nums2[index2][1]});
                index1++;
                index2++;
            } else if (nums1[index1][0] < nums2[index2][0]) {
                result.push_back({nums1[index1][0], nums1[index1][1]});
                index1++;
            } else {
                result.push_back({nums2[index2][0], nums2[index2][1]});
                index2++;
            }
        } else if (index1 < nums1.size()) {
            result.push_back({nums1[index1][0], nums1[index1][1]});
            index1++;
        } else {
            result.push_back({nums2[index2][0], nums2[index2][1]});
            index2++;
        }
    }
    return result;
}
```

[350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)

```
vector<int> intersect(vector<int> &nums1, vector<int> &nums2) {
    sort(nums1.begin(), nums1.end());
    sort(nums2.begin(), nums2.end());
    vector<int> result;
    int i = 0;
    int j = 0;
    while (i < nums1.size() && j < nums2.size()) {
        if (nums1[i] == nums2[j]) {
            result.push_back(nums1[i]);
            i++;
            j++;
        } else if (nums1[i] < nums2[j]) {
            i++;
        } else {
            j++;
        }
    }
    return result;
}
```

[LCP 18. 早餐组合](https://leetcode.cn/problems/2vYnGI/)

```
int breakfastNumber(vector<int> &staple, vector<int> &drinks, int x) {
    sort(staple.begin(), staple.end());
    sort(drinks.begin(), drinks.end());
    const auto less = [&](vector<int> &arr, int target) {
        int left = 0;
        int right = arr.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                int index = mid;
                while (index > 0 && arr[index] == arr[index - 1]) {
                    index--;
                }
                return index;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    };
    const int mod = 1e9 + 7;
    int result = 0;
    for (int i = 0; i < staple.size() && staple[i] < x; i++) {
        int n = less(drinks, x - staple[i] + 1);
        result = (result + less(drinks, x - staple[i] + 1)) % mod;
    }
    return result;
}
```

[855. 下标对中的最大距离](https://leetcode.cn/problems/maximum-distance-between-a-pair-of-values/)

```
int maxDistance(vector<int> &nums1, vector<int> &nums2) {
    int result = 0;
    int i = 0;
    int j = 0;
    while (i < nums1.size()) {
        while (j < nums2.size() && nums1[i] <= nums2[j]) {
            j++;
        }
        result = max(result, j - i - 1);
        i++;
    }
    return result;
}
```

[1385. 两个数组间的距离值](https://leetcode.cn/problems/find-the-distance-value-between-two-arrays/)

```
int findTheDistanceValue(vector<int> &arr1, vector<int> &arr2, int d) {
    int result = 0;
    for (int i = 0; i < arr1.size(); i++) {
        bool flag = true;
        for (int j = 0; j < arr2.size(); j++) {
            if (abs(arr1[i] - arr2[j]) <= d) {
                flag = false;
                break;
            }
        }
        if (flag) {
            result++;
        }
    }
    return result;
}
```

[925. 长按键入](https://leetcode.cn/problems/long-pressed-name/)

```
bool isLongPressedName(string name, string typed) {
    int i = 0;
    int j = 0;
    while (i < name.length() && j < typed.length() && name[i] == typed[j]) {
        int count1 = 0;
        char character1 = name[i];
        while (i < name.length() && name[i] == character1) {
            count1++;
            i++;
        }

        int count2 = 0;
        char character2 = typed[j];
        while (j < typed.length() && typed[j] == character2) {
            count2++;
            j++;
        }
        if (count1 > count2) {
            return false;
        }
    }
    return i == name.length() && j == typed.length();
}
```

[809. 情感丰富的文字](https://leetcode.cn/problems/expressive-words/)

```
int expressiveWords(string s, vector<string> &words) {
    const auto stretchy = [](const string &s, const string &word) {
        int i = 0;
        int j = 0;
        while (i < s.length() && j < word.length() && s[i] == word[j]) {
            int count1 = 0;
            char character1 = s[i];
            while (i < s.length() && s[i] == character1) {
                count1++;
                i++;
            }

            int count2 = 0;
            char character2 = word[j];
            while (j < word.length() && word[j] == character2) {
                count2++;
                j++;
            }
            if (count1 < count2 || count1 < 3 && count1 != count2) {
                return false;
            }
        }
        return i == s.length() && j == word.length();
    };
    int result = 0;
    for (const auto word: words) {
        result += stretchy(s, word) ? 1 : 0;
    }
    return result;
}
```

[2337. 移动片段得到字符串](https://leetcode.cn/problems/move-pieces-to-obtain-a-string/)

```
bool canChange(string start, string target) {
    int i = 0;
    int j = 0;
    while (i < start.length() || j < target.length()) {
        while (i < start.length() && start[i] == '_') {
            i++;
        }

        while (j < target.length() && target[j] == '_') {
            j++;
        }

        if (i == start.length() || j == target.length()) {
            return i == start.length() && j == target.length();
        }

        if (start[i] != target[j] || (start[i] == 'L' && i < j) || (start[i] == 'R' && i > j)) {
            return false;
        }

        i++;
        j++;
    }
    return i == start.length() && j == target.length();
}
```

[777. 在 LR 字符串中交换相邻字符](https://leetcode.cn/problems/swap-adjacent-in-lr-string/)

```
bool canTransform(string start, string result) {
    int i = 0;
    int j = 0;
    while (i < start.length() || j < result.length()) {
        while (i < start.length() && start[i] == 'X') {
            i++;
        }

        while (j < result.length() && result[j] == 'X') {
            j++;
        }

        if (i == start.length() || j == result.length()) {
            return i == start.length() && j == result.length();
        }

        if (start[i] != result[j] || (start[i] == 'L' && i < j) || (start[i] == 'R' && i > j)) {
            return false;
        }

        i++;
        j++;
    }
    return i == start.length() && j == result.length();
}
```

[844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

```
bool backspaceCompare(string s, string t) {
    int i = s.length();
    int j = t.length();
    int count1 = 0;
    int count2 = 0;
    while (i >= 0 || j >= 0) {
        while (i >= 0) {
            if (s[i] == '#') {
                count1++;
                i--;
            } else {
                if (count1 > 0) {
                    count1--;
                    i--;
                } else {
                    break;
                }
            }
        }

        while (j >= 0) {
            if (t[j] == '#') {
                count2++;
                j--;
            } else {
                if (count2 > 0) {
                    count2--;
                    j--;
                } else {
                    break;
                }
            }
        }

        if (i >= 0 && j >= 0) {
            if (s[i] != t[j]) {
                return false;
            }
        } else if (i >= 0 || j >= 0) {
            return false;
        }

        i--;
        j--;
    }
    return true;
}
```

[986. 区间列表的交集](https://leetcode.cn/problems/interval-list-intersections/)

```
vector<vector<int>> intervalIntersection(vector<vector<int>> &firstList, vector<vector<int>> &secondList) {
    vector<vector<int>> result;
    int i = 0;
    int j = 0;
    while (i < firstList.size() && j < secondList.size()) {
        int low = max(firstList[i][0], secondList[j][0]);
        int high = min(firstList[i][1], secondList[j][1]);
        if (low <= high) {
            result.push_back({max(firstList[i][0], secondList[j][0]), min(firstList[i][1], secondList[j][1])});
        }
        if (firstList[i][1] < secondList[j][1]) {
            i++;
        } else {
            j++;
        }
    }
    return result;
}
```

[面试题 16.06. 最小差](https://leetcode.cn/problems/smallest-difference-lcci/)

```
int smallestDifference(vector<int> &a, vector<int> &b) {
    sort(a.begin(), a.end());
    sort(b.begin(), b.end());
    long long result = LONG_LONG_MAX;
    int i = 0;
    int j = 0;
    while (i < a.size() && j < b.size()) {
        if (a[i] != b[j]) {
            result = min(result, abs(static_cast<long long>(a[i]) - static_cast<long long>(b[j])));
            if (a[i] < b[j]) {
                i++;
            } else {
                j++;
            }
        } else {
            return 0;
        }
    }
    return result;
}
```

[1537. 最大得分](https://leetcode.cn/problems/get-the-maximum-score/)

```
int maxSum(vector<int> &nums1, vector<int> &nums2) {
    const long long MOD = 1e9 + 7;
    int i = 0;
    int j = 0;
    long long sum1 = 0;
    long long sum2 = 0;
    while (i < nums1.size() && j < nums2.size()) {
        if (nums1[i] < nums2[j]) {
            sum1 += nums1[i];
            i++;
        } else if (nums1[i] > nums2[j]) {
            sum2 += nums2[j];
            j++;
        } else {
            sum1 = sum2 = max(sum1, sum2) + nums1[i];
            i++;
            j++;
        }
    }

    while (i < nums1.size()) {
        sum1 += nums1[i];
        i++;
    }

    while (j < nums2.size()) {
        sum2 += nums2[j];
        j++;
    }
    return static_cast<int>(max(sum1, sum2) % MOD);
}
```

##### 子序列

[392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

```
bool isSubsequence(string s, string t) {
    int i = 0;
    int j = 0;
    while (i < s.length() && j < t.length()) {
        if (s[i] == t[j]) {
            i++;
        }
        j++;
    }
    return s.empty() || i == s.length();
}
```

[524. 通过删除字母匹配到字典里最长单词](https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/)

```
string findLongestWord(string s, vector<string> &dictionary) {
    const auto isSubsequence = [](string s, string t) {
        int i = 0;
        int j = 0;
        while (i < s.length() && j < t.length()) {
            if (s[i] == t[j]) {
                i++;
            }
            j++;
        }
        return s.empty() || i == s.length();
    };
    string result;
    for (const auto d: dictionary) {
        if (isSubsequence(d, s) && result.length() <= d.length()) {
            if (result.length() < d.length()) {
                result = d;
            } else {
                if (result > d) {
                    result = d;
                }
            }
        }
    }
    return result;
}
```

[2486. 追加字符以获得子序列](https://leetcode.cn/problems/append-characters-to-string-to-make-subsequence/)

```
int appendCharacters(string s, string t) {
    int i = 0;
    int j = 0;
    while (i < s.length() && j < t.length()) {
        if (s[i] == t[j]) {
            j++;
        }
        i++;
    }
    return t.length() - j;
}
```

[2825. 循环增长使字符串子序列等于另一个字符串](https://leetcode.cn/problems/make-string-a-subsequence-using-cyclic-increments/)

```
bool canMakeSubsequence(string str1, string str2) {
    int i = 0;
    int j = 0;
    while (i < str1.length() && j < str2.length()) {
        if (str1[i] == str2[j] || (str1[i] - 'a' + 1) % 26 + 'a' == str2[j]) {
            j++;
        }
        i++;
    }
    return j == str2.length();
}
```

[1023. 驼峰式匹配](https://leetcode.cn/problems/camelcase-matching/)

```
vector<bool> camelMatch(vector<string> &queries, string pattern) {
    const auto match = [](string s, string t) {
        int i = 0;
        int j = 0;
        while (i < s.length() && j < t.length()) {
            if (s[i] == t[j]) {
                i++;
            } else {
                if (isupper(t[j])) {
                    return false;
                }
            }
            j++;
        }
        while (j < t.length()) {
            if (isupper(t[j])) {
                return false;
            }
            j++;
        }
        return s.empty() || i == s.length();
    };
    vector<bool> result(queries.size(), false);
    for (int i = 0; i < queries.size(); i++) {
        result[i] = match(pattern, queries[i]);
    }
    return result;
}
```

[3132. 找出与数组相加的整数 II](https://leetcode.cn/problems/find-the-integer-added-to-array-ii/)

```
int minimumAddedInteger(vector<int> &nums1, vector<int> &nums2) {
    sort(nums1.begin(), nums1.end());
    sort(nums2.begin(), nums2.end());
    for (int n = 2; n > 0; n--) {
        int x = nums2[0] - nums1[n];
        int i = n;
        int j = 0;
        while (i < nums1.size() && j < nums2.size()) {
            if (nums2[j] == nums1[i] + x) {
                j++;
            }
            i++;
        }
        if (j == nums2.size()) {
            return x;
        }
    }
    return nums2[0] - nums1[0];
}
```

[522. 最长特殊序列 II](https://leetcode.cn/problems/longest-uncommon-subsequence-ii/)

```
int findLUSlength(vector<string> &strs) {
    const auto isSubsequence = [](string s, string t) {
        int i = 0;
        int j = 0;
        while (i < s.length() && j < t.length()) {
            if (s[i] == t[j]) {
                i++;
            }
            j++;
        }
        return s.empty() || i == s.length();
    };
    string result;
    for (int i = 0; i < strs.size(); i++) {
        bool found = true;
        for (int j = 0; j < strs.size(); j++) {
            if (i != j && isSubsequence(strs[i], strs[j])) {
                found = false;
                break;
            }
        }
        if (found) {
            if (result.length() < strs[i].length()) {
                result = strs[i];
            }
        }
    }
    return result.empty() ? -1 : result.length();
}
```

#### 三指针

[2367. 等差三元组的数目](https://leetcode.cn/problems/number-of-arithmetic-triplets/)

```
int arithmeticTriplets(vector<int> &nums, int diff) {
    int result = 0;
    int i = 0;
    int j = i + 1;
    for (const auto &num: nums) {
        while (nums[j] + diff < num) {
            j++;
        }
        if (nums[j] + diff == num) {
            while (nums[i] + diff < nums[j]) {
                i++;
            }
            if (nums[i] + diff == nums[j]) {
                result++;
            }
        }
    }
    return result;
}
```

[2563. 统计公平数对的数目](https://leetcode.cn/problems/count-the-number-of-fair-pairs/)

```
long long countFairPairs(vector<int> &nums, int lower, int upper) {
    long long result = 0;
    sort(nums.begin(), nums.end());
    int left = nums.size();
    int right = nums.size();
    for (int j = 0; j < nums.size(); j++) {
        while (right > 0 && nums[right - 1] > upper - nums[j]) {
            right--;
        }
        while (left > 0 && nums[left - 1] >= lower - nums[j]) {
            left--;
        }
        result += min(right, j) - min(left, j);
    }
    return result;
}
```

[795. 区间子数组个数](https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum/)

```
int numSubarrayBoundedMax(vector<int> &nums, int left, int right) {
    int result = 0;
    int l = -1;
    int r = -1;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] > right) {
            l = i;
        }
        if (nums[i] >= left) {
            r = i;
        }
        result += r - l;
    }
    return result;
}
```

[2444. 统计定界子数组的数目](https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/)

```
long long countSubarrays(vector<int> &nums, int minK, int maxK) {
    long long result = 0;
    int mini = -1;
    int maxi = -1;
    int index = -1;
    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] == maxK) {
            maxi = i;
        }
        if (nums[i] == minK) {
            mini = i;
        }
        if (nums[i] < minK || nums[i] > maxK) {
            index = i;
        }
        result += max(0, min(mini, maxi) - index);
    }
    return result;
}
```

#### 分组循环

- 外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）
- 内层循环负责遍历组，找出这一组最远在哪结束

[1446. 连续字符](https://leetcode.cn/problems/consecutive-characters/)

```
int maxPower(string s) {
    int result = 1;
    int i = 0;
    while (i < s.length()) {
        int j = i + 1;
        while (j < s.length() && s[j] == s[i]) {
            j++;
        }
        result = max(result, j - i);
        i = j;
    }
    return result;
}
```

[1869. 哪种连续子字符串更长](https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/)

```
bool checkZeroOnes(string s) {
    vector<int> count(2, 0);
    int i = 0;
    while (i < s.length()) {
        int j = i + 1;
        while (j < s.length() && s[j] == s[i]) {
            j++;
        }
        count[s[i] - '0'] = max(count[s[i] - '0'], j - i);
        i = j;
    }
    return count[1] > count[0];
}
```

[2414. 最长的字母序连续子字符串的长度](https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/)

```
int longestContinuousSubstring(string s) {
    int result = 0;
    int i = 0;
    while (i < s.length()) {
        int j = i + 1;
        while (j < s.length() && s[j] == s[j - 1] + 1) {
            j++;
        }
        result = max(result, j - i);
        i = j;
    }
    return result;
}
```

[3456. 找出长度为 K 的特殊子字符串](https://leetcode.cn/problems/find-special-substring-of-length-k/)

```
bool hasSpecialSubstring(string s, int k) {
    int i = 0;
    while (i < s.length()) {
        int j = i + 1;
        while (j < s.length() && s[j] == s[i]) {
            j++;
        }
        if (j - i == k) {
            return true;
        }
        i = j;
    }
    return false;
}
```

[2348. 全 0 子数组的数目](https://leetcode.cn/problems/number-of-zero-filled-subarrays/)

```
long long zeroFilledSubarray(vector<int> &nums) {
    long long result = 0;
    int count = 0;
    for (const auto &num: nums) {
        if (num) {
            count = 0;
        } else {
            count++;
            result += count;
        }
    }
    return result;
}
```

[1957. 删除字符使字符串变好](https://leetcode.cn/problems/delete-characters-to-make-fancy-string/)

```
string makeFancyString(string s) {
    string result;
    int i = 0;
    while (i < s.length()) {
        int j = i + 1;
        while (j < s.length() && s[j] == s[i]) {
            j++;
        }
        if (j - i >= 3) {
            result += string(2, s[i]);
        } else {
            result += s.substr(i, j - i);
        }
        i = j;
    }
    return result;
}
```

[674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

```
int findLengthOfLCIS(vector<int>& nums) {
    int result = 0;
    int i = 0;
    while (i < nums.size()) {
        int j = i + 1;
        while (j < nums.size() && nums[j] > nums[j - 1]) {
            j++;
        }
        result = max(result, j - i);
        i = j;
    }
    return result;
}
```

[978. 最长湍流子数组](https://leetcode.cn/problems/longest-turbulent-subarray/)

```
int maxTurbulenceSize(vector<int> &arr) {
    if (arr.size() < 2) {
        return arr.size();
    }
    int result = 1;
    int i = 0;
    int j = 1;
    while (j < arr.size()) {
        int cmp = (arr[j] > arr[j - 1]) - (arr[j] < arr[j - 1]);
        if (cmp == 0) {
            i = j;
        } else {
            if (j == arr.size() - 1 || cmp * ((arr[j] < arr[j + 1]) - (arr[j] > arr[j + 1])) >= 0) {
                result = max(result, j - i + 1);
                i = j;
            }
        }
        j++;
    }
    return result;
}
```

[2110. 股票平滑下跌阶段的数目](https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/)

```
long long getDescentPeriods(vector<int> &prices) {
    long long result = 0;
    int count = 0;
    for (int i = 0; i < prices.size(); i++) {
        if (i == 0 || prices[i] == prices[i - 1] - 1) {
            count++;
        } else {
            count = 1;
        }
        result += count;
    }
    return result;
}
```

[228. 汇总区间](https://leetcode.cn/problems/summary-ranges/)

```
vector<string> summaryRanges(vector<int> &nums) {
    if (nums.empty()) {
        return vector<string>();
    }
    vector<string> result;
    int i = 0;
    int j = 1;
    while (j < nums.size()) {
        if (nums[j] != nums[j - 1] + 1) {
            if (i != j - 1) {
                result.push_back(to_string(nums[i]) + "->" + to_string(nums[j - 1]));
            } else {
                result.push_back(to_string(nums[i]));
            }
            i = j;
        }
        j++;
    }
    if (i != j - 1) {
        result.push_back(to_string(nums[i]) + "->" + to_string(nums[j - 1]));
    } else {
        result.push_back(to_string(nums[i]));
    }
    return result;
}
```

[2760. 最长奇偶子数组](https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/)

```
int longestAlternatingSubarray(vector<int> &nums, int threshold) {
    int result = 0;
    int i = 0;
    int j = 0;
    while (j < nums.size()) {
        if (nums[j] <= threshold && nums[j] % 2 == 0) {
            i = j;
            j = i + 1;
            while (j < nums.size() && nums[j] <= threshold && nums[j] % 2 != nums[j - 1] % 2) {
                j++;
            }
            result = max(result, j - i);
            j--;
        }
        j++;
    }
    return result;
}
```

[1887. 使数组元素相等的减少操作次数](https://leetcode.cn/problems/reduction-operations-to-make-the-array-elements-equal/)

```
int reductionOperations(vector<int> &nums) {
    sort(nums.begin(), nums.end(), greater<int>());
    int result = 0;
    int i = 0;
    int j = 1;
    while (j < nums.size()) {
        if (nums[j] != nums[i]) {
            result += j;
            i = j;
        }
        j++;
    }
    return result;
}
```

[2038. 如果相邻两个颜色均相同则删除当前颜色](https://leetcode.cn/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/)

```
bool winnerOfGame(string colors) {
    int result = 0;
    int i = 0;
    int j = 1;
    vector<int> count(2, 0);
    while (j < colors.length()) {
        if (colors[j] != colors[i]) {
            if (j - i >= 3) {
                count[colors[i] - 'A'] += j - i - 2;
            }
            i = j;
        }
        j++;
    }
    if (j - i >= 3) {
        count[colors[i] - 'A'] += j - i - 2;
    }
    return count[0] > count[1];
}
```

[2900. 最长相邻不相等子序列 I](https://leetcode.cn/problems/longest-unequal-adjacent-groups-subsequence-i/)

```
vector<string> getLongestSubsequence(vector<string> &words, vector<int> &groups) {
    vector<string> result;
    result.emplace_back(words[0]);
    int i = 0;
    int j = 1;
    while (j < groups.size()) {
        if (groups[j] != groups[i]) {
            result.emplace_back(words[j]);
            i = j;
        }
        j++;
    }
    return result;
}
```

[1759. 统计同质子字符串的数目](https://leetcode.cn/problems/count-number-of-homogenous-substrings/)

```
int countHomogenous(string s) {
    const int MOD = 1e9 + 7;
    int result = 0;
    int i = 0;
    int j = 1;
    while (j < s.length()) {
        result = (result + j - i) % MOD;
        if (s[j] != s[i]) {
            i = j;
        }
        j++;
    }
    return (result + j - i) % MOD;;
}
```

[3011. 判断一个数组是否可以变为有序](https://leetcode.cn/problems/find-if-array-can-be-sorted/)

```
bool canSortArray(vector<int> &nums) {
    int premaximum = 0;
    int maximum = nums[0];
    int minimum = nums[0];
    int i = 0;
    int j = 1;
    while (j < nums.size()) {
        if (__builtin_popcount(nums[i]) != __builtin_popcount(nums[j])) {
            if (premaximum > minimum) {
                return false;
            }
            premaximum = maximum;
            maximum = nums[j];
            minimum = nums[j];
            i = j;
        } else {
            maximum = max(maximum, nums[j]);
            minimum = min(minimum, nums[j]);
        }
        j++;
    }
    return premaximum == 0 || premaximum <= minimum;
}
```

[1578. 使绳子变成彩色的最短时间](https://leetcode.cn/problems/minimum-time-to-make-rope-colorful/)

```
int minCost(string colors, vector<int> &neededTime) {
    int result = 0;
    int maximum = neededTime[0];
    int sum = neededTime[0];
    int i = 0;
    int j = 1;
    while (j < colors.length()) {
        if (colors[j] != colors[i]) {
            if (j - i > 1) {
                result += sum - maximum;
            }
            maximum = neededTime[j];
            sum = neededTime[j];
            i = j;
        } else {
            maximum = max(maximum, neededTime[j]);
            sum += neededTime[j];
        }
        j++;
    }
    return j - i > 1 ? result + sum - maximum : result;
}
```

[1839. 所有元音按顺序排布的最长子字符串](https://leetcode.cn/problems/longest-substring-of-all-vowels-in-order/)

```
int longestBeautifulSubstring(string word) {
    int result = 0;
    unordered_map<char, char> next = {
            {'a', 'e'},
            {'e', 'i'},
            {'i', 'o'},
            {'o', 'u'},
    };
    int i = 0;
    int j = 0;
    while (i < word.length()) {
        if (word[i] == 'a') {
            int count = 1;
            char previous = word[i];
            int j = i + 1;
            while (j < word.length() && (word[j] == previous || word[j] == next[previous])) {
                if (word[j] == next[previous]) {
                    count++;
                    previous = word[j];
                }
                j++;
            }
            if (count == 5) {
                result = max(result, j - i);
            }
            i = j;
        } else {
            i++;
        }
    }
    return result;
}
```

[2765. 最长交替子数组](https://leetcode.cn/problems/longest-alternating-subarray/)

```
int alternatingSubarray(vector<int> &nums) {
    int result = -1;
    int i = 0;
    while (i < nums.size() - 1) {
        if (nums[i + 1] - nums[i] != 1) {
            i++;
            continue;
        }
        int j = i + 2;
        while (j < nums.size() && nums[j] == nums[j - 2]) {
            j++;
        }
        result = max(result, j - i);
        i = j - 1;
    }
    return result;
}
```

[3350. 检测相邻递增子数组 II](https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-ii/)

```
int maxIncreasingSubarrays(vector<int>& nums) {
    int result = 0;
    int previous = 0;
    int i = 0;
    while (i < nums.size()) {
        int current = 1;
        int j = i + 1;
        while (j < nums.size() && nums[j] > nums[j - 1]) {
            current++;
            j++;
        }
        result = max({result, current / 2, min(previous, current)});
        previous = current;
        i = j;
    }
    return result;
}
```

[3105. 最长的严格递增或递减子数组](https://leetcode.cn/problems/longest-strictly-increasing-or-strictly-decreasing-subarray/)

```
int longestMonotonicSubarray(vector<int> &nums) {
    int result = 0;
    int i = 0;
    while (i < nums.size()) {
        int j = i + 1;
        while (j < nums.size() && nums[j] > nums[j - 1]) {
            j++;
        }
        int k = i + 1;
        while (k < nums.size() && nums[k] < nums[k - 1]) {
            k++;
        }
        result = max({result, j - i, k - i});
        i = min(j, k);
    }
    return result;
}
```

[413. 等差数列划分](https://leetcode.cn/problems/arithmetic-slices/)

```
int numberOfArithmeticSlices(vector<int> &nums) {
    if (nums.size() < 3) {
        return 0;
    }
    int result = 0;
    int i = 0;
    int j = 1;
    int d = nums[j] - nums[j - 1];
    while (j < nums.size()) {
        if (j - i >= 3) {
            result += j - i - 2;
        }
        if (nums[j] - nums[j - 1] != d) {
            d = nums[j] - nums[j - 1];
            i = j - 1;
        }
        j++;
    }
    return j - i >= 3 ? result + j - i - 2 : result;
}
```

[467. 环绕字符串中唯一的子字符串](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/)

```
int findSubstringInWraproundString(string p) {
    vector<int> result(26, 0);
    int i = 0;
    while (i < p.length()) {
        int j = i + 1;
        while (j < p.length() && (p[j] - p[j - 1] + 26) % 26 == 1) {
            j++;
        }
        for (int k = i; k < j; k++) {
            result[p[k] - 'a'] = max(result[p[k] - 'a'], j - k);
        }
        i = j;
    }
    return accumulate(result.begin(), result.end(), 0);
}
```

## 二分算法

### 二分查找

- lower_bound用于查找有序序列中第一个不小于给定值的元素位置，即求$Element \ge Value$的位置
- upper_bound用于查找有序序列中第一个大于给定值的元素位置，即求$Element > Value$的位置

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```
vector<int> searchRange(vector<int> &nums, int target) {
    const auto lower = [](vector<int> &nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    };
    int start = lower(nums, target);
    if (start == nums.size() || nums[start] != target) {
        return {-1, -1};
    }
    int end = lower(nums, target + 1) - 1;
    return {start, end};
}
```

[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

```
int searchInsert(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return left;
}
```

[704. 二分查找](https://leetcode.cn/problems/binary-search/)

```
int search(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
}
```

[744. 寻找比目标字母大的最小字母](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/)

```
char nextGreatestLetter(vector<char> &letters, char target) {
    const auto lower = [](vector<char> &letters, char target) {
        int left = 0;
        int right = letters.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (letters[mid] >= target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    };
    // int result = lower(letters, target + 1);

    const auto upper = [](vector<char> &letters, char target) {
        int left = 0;
        int right = letters.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (letters[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    };
    int result = upper(letters, target);
    return result == letters.size() ? letters[0] : letters[result];
}
```

[2529. 正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/)

```
int maximumCount(vector<int> &nums) {
    const auto lower = [](vector<int> &nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    };

    const auto upper = [](vector<int> &nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    };
    return max(lower(nums, 0), static_cast<int>(nums.size()) - upper(nums, 0));
}
```

### 二分问题

#### 求最小

- 对于闭区间来说：当`check(mid) == true` 时`right = mid - 1` ，反之 `left = mid + 1`，最后返回 `left`

[1283. 使结果不超过阈值的最小除数](https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/)

```
int smallestDivisor(vector<int> &nums, int threshold) {
    const auto check = [&](int x) {
        int sum = 0;
        for (const auto &num: nums) {
            sum += (num + x - 1) / x;
        }
        return sum <= threshold;
    };
    int left = 1;
    int right = *max_element(nums.begin(), nums.end());
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (check(mid)) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

[2187. 完成旅途的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/)

```
long long minimumTime(vector<int> &time, int totalTrips) {
    const auto check = [&](long long x) {
        long long sum = 0;
        for (const auto &t: time) {
            sum += x / t;
        }
        return sum >= totalTrips;
    };
    int minimum = *min_element(time.begin(), time.end());
    long long left = minimum;
    long long right = 1LL * minimum * totalTrips;
    while (left <= right) {
        long long mid = left + (right - left) / 2;
        if (check(mid)) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

[1011. 在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)

```
int shipWithinDays(vector<int> &weights, int days) {
    const auto check = [&](int capacity) {
        int sum = 1;
        int c = capacity;
        for (const auto &weight: weights) {
            if (c >= weight) {
                c -= weight;
            } else {
                c = capacity - weight;
                sum++;
            }
        }
        return sum <= days;
    };
    int maximum = *max_element(weights.begin(), weights.end());
    int left = maximum;
    int right = weights.size() * maximum;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        std::cout << mid << std::endl;
        if (check(mid)) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

[875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)

```
int minEatingSpeed(vector<int> &piles, int h) {
    const auto check = [&](int k) {
        long long sum = piles.size();
        for (const auto &pile: piles) {
            sum += (pile - 1) / k;
        }
        return sum <= h;
    };
    int left = 1;
    int right = *max_element(piles.begin(), piles.end());
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (check(mid)) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

#### 求最大

对于闭区间来说：当`check(mid) == true` 时`left = mid + 1` ，反之`right = mid - 1` ，最后返回 `right`

[275. H 指数 II](https://leetcode.cn/problems/h-index-ii/)

```
int hIndex(vector<int> &citations) {
    const auto check = [&](int c) {
        int sum = 0;
        for (const auto &citation: citations) {
            if (c <= citation) {
                sum++;
            }
        }
        return sum >= c;
    };
    int left = 0;
    int right = citations[citations.size() - 1];
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (check(mid)) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return right;
}
```

[2226. 每个小孩最多能分到多少糖果](https://leetcode.cn/problems/maximum-candies-allocated-to-k-children/)

```
int maximumCandies(vector<int> &candies, long long k) {
    const auto check = [&](long long c) {
        long long sum = 0;
        for (const auto &candy: candies) {
            sum += candy / c;
        }
        return sum >= k;
    };
    long long left = 1;
    long long right = accumulate(candies.begin(), candies.end(), 0LL) / k;
    while (left <= right) {
        long long mid = left + (right - left) / 2;
        if (check(mid)) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return right;
}
```

#### 求间接值

[3143. 正方形中的最多点数](https://leetcode.cn/problems/maximum-points-inside-the-square/)

```
int maxPointsInsideSquare(vector<vector<int>> &points, string s) {
    int result = 0;
    const auto check = [&](int size) {
        unordered_map<char, bool> map;
        for (int i = 0; i < points.size(); i++) {
            if (abs(points[i][0]) <= size && abs(points[i][1]) <= size) {
                if (!map.contains(s[i])) {
                    map[s[i]] = true;
                } else {
                    return false;
                }
            }
        }
        result = map.size();
        return true;
    };
    int left = 0;
    int right = 1e9 + 7;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (check(mid)) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}
```

#### 最小化最大值

- 本质上是**求最小**

[410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/)

```
int splitArray(vector<int> &nums, int k) {
    const auto check = [&](int maximum) {
        int sum = 0;
        int count = 1;
        for (const auto &num: nums) {
            if (sum + num <= maximum) {
                sum += num;
            } else {
                sum = num;
                count++;
            }
        }
        return count <= k;
    };
    int left = *max_element(nums.begin(), nums.end());
    int right = accumulate(nums.begin(), nums.end(), 0);
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (check(mid)) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

#### 最大化最小值

[3281. 范围内整数的最大得分](https://leetcode.cn/problems/maximize-score-of-numbers-in-ranges/)

```
int maxPossibleScore(vector<int> &start, int d) {
    sort(start.begin(), start.end());
    const auto check = [&](int minimum) {
        long long previous = LLONG_MIN;
        for (const auto &s: start) {
            previous = max(previous + minimum, static_cast<long long>(s));
            if (previous > s + d) {
                return false;
            }
        }
        return true;
    };
    int left = 0;
    int right = start[start.size() - 1] + d - start[0];
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (check(mid)) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return right;
}
```

#### 第K小/第K大

- 第 *k* 小等价于：求**最小**的 *x*，满足 ≤*x* 的数**至少**有 *k* 个。
- 第 *k* 大等价于：求**最大**的 *x*，满足 ≥*x* 的数**至少**有 *k* 个。

[378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/)

```
int kthSmallest(vector<vector<int>> &matrix, int k) {
    const auto check = [&](int maximum) {
        int count = 0;
        int i = 0;
        int j = matrix[0].size() - 1;
        while (i < matrix.size() && j >= 0) {
            if (matrix[i][j] > maximum) {
                j--;
            } else {
                count += j + 1;
                i++;
            }
        }
        return count >= k;
    };
    int left = matrix[0][0];
    int right = matrix[matrix.size() - 1][matrix[0].size() - 1];
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (check(mid)) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

### 山脉数组

[162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

```
int findPeakElement(vector<int> &nums) {
    int left = 0;
    int right = nums.size() - 2;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > nums[mid + 1]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

[852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)

```
int peakIndexInMountainArray(vector<int> &arr) {
    int left = 0;
    int right = arr.size() - 2;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] > arr[mid + 1]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

[1095. 山脉数组中查找目标值](https://leetcode.cn/problems/find-in-mountain-array/)

```
int findInMountainArray(int target, MountainArray &mountainArr) {
    const auto getTop = [&]() {
        int left = 0;
        int right = mountainArr.length() - 2;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (mountainArr.get(mid) > mountainArr.get(mid + 1)) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    };
    int top = getTop();
    const auto searchLeft = [&](int left, int right) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (mountainArr.get(mid) == target) {
                return mid;
            } else if (mountainArr.get(mid) < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    };
    const auto searchRight = [&](int left, int right) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (mountainArr.get(mid) == target) {
                return mid;
            } else if (mountainArr.get(mid) < target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1;
    };
    int result = searchLeft(0, top);
    if (result != -1) {
        return result;
    } else {
        return searchRight(top + 1, mountainArr.length() - 1);
    }
}
```

### 旋转排列数组

[153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

```
int findMin(vector<int> &nums) {
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < nums[right]) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return nums[left];
}
```

[154. 寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/)

```
int findMin(vector<int> &nums) {
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < nums[right]) {
            right = mid;
        } else if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            right--;
        }
    }
    return nums[left];
}
```

[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```
int search(vector<int> &nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target <= nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] <= target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return -1;
}
```

[81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)

```
bool search(vector<int> &nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return true;
        }

        if (nums[left] == nums[mid] && nums[mid] == nums[right]) {
            left++;
            right--;
        } else if (nums[left] <= nums[mid]) {
            if (nums[left] <= target && target <= nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            if (nums[mid] <= target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return false;
}
```

### 其他

[69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

```
int mySqrt(int x) {
    int result = 0;
    long long left = 0;
    long long right = x;
    while (left <= right) {
        long long mid = left + (right - left) / 2;
        if (mid * mid == x) {
            return mid;
        } else if (mid * mid < x) {
            left = mid + 1;
            result = mid;
        } else {
            right = mid - 1;
        }
    }
    return result;
}
```

[74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

```
bool searchMatrix(vector<vector<int>> &matrix, int target) {
    int left = 0;
    int right = matrix.size() * matrix[0].size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        std::cout << mid << std::endl;
        if (matrix[mid / matrix[0].size()][mid % matrix[0].size()] == target) {
            return true;
        } else if (matrix[mid / matrix[0].size()][mid % matrix[0].size()] <= target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return false;
}
```

[2476. 二叉搜索树最近节点查询](https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/)

```
vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {
    vector<int> nums;
    std::function<void(TreeNode*)> dfs = [&](TreeNode* node) {
        if (node) {
            dfs(node->left);
            nums.emplace_back(node->val);
            dfs(node->right);
        }
    };
    dfs(root);
    vector<vector<int>> result;
    for (const auto& query : queries) {
        int left = 0;
        int right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == query) {
                left = mid;
                right = mid;
                break;
            } else if (nums[mid] < query) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        int minimum = right >= 0 ? nums[right] : -1;
        int maximum = left < nums.size() ? nums[left] : -1;
        result.push_back({minimum, maximum});
    }
    return result;
}
```

[278. 第一个错误的版本](https://leetcode.cn/problems/first-bad-version/)

```
int firstBadVersion(int n) {
    int left = 1;
    int right = n;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (isBadVersion(mid)) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
```

[374. 猜数字大小](https://leetcode.cn/problems/guess-number-higher-or-lower/)

```
int guessNumber(int n) {
    int left = 1;
    int right = n;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (!guess(mid)) {
            return mid;
        } else if (guess(mid) > 0) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return 0;
}
```

[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

```
int countNodes(TreeNode *root) {
    return root ? 1 + countNodes(root->left) + countNodes(root->right) : 0;
}
```

[540. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/)

```
int singleNonDuplicate(vector<int> &nums) {
    int left = 0;
    int right = nums.size() - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == nums[mid ^ 1]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return nums[left];
}
```

## 数据结构与算法思想

### 枚举技巧

#### 维护左枚举右

- 对于 双变量问题，例如两数之和 $a_i+a_j=t$ ，可以使用哈希表维护 $a_i$，枚举右边的 $a_j$ ，查找是否存在 $a_i=t-a_j$ 。

[1. 两数之和](https://leetcode.cn/problems/two-sum/)

```
vector<int> twoSum(vector<int> &nums, int target) {
    unordered_map<int, int> map;
    for (int i = 0; i < nums.size(); i++) {
        if (map.contains(target - nums[i])) {
            return {i, map[target - nums[i]]};
        }
        map[nums[i]] = i;
    }
    return {-1, -1};
}
```

[2441. 与对应负数同时存在的最大正整数](https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/)

```
int findMaxK(vector<int> &nums) {
    int result = -1;
    unordered_set<int> set;
    for (const auto &num: nums) {
        if (set.contains(-num)) {
            result = max(result, abs(num));
        }
        set.insert(num);
    }
    return result;
}
```

[1512. 好数对的数目](https://leetcode.cn/problems/number-of-good-pairs/)

```
int numIdenticalPairs(vector<int> &nums) {
    int result = 0;
    unordered_map<int, int> map;
    for (const auto &num: nums) {
        result += map[num];
        map[num]++;
    }
    return result;
}
```

[2001. 可互换矩形的组数](https://leetcode.cn/problems/number-of-pairs-of-interchangeable-rectangles/)

```
long long interchangeableRectangles(vector<vector<int>> &rectangles) {
    long long result = 0;
    map<pair<int, int>, long long> map;
    for (const auto &rectangle: rectangles) {
        int w = rectangle[0];
        int h = rectangle[1];
        int g = gcd(w, h);
        w /= g;
        h /= g;
        result += map[make_pair(w, h)];
        map[make_pair(w, h)]++;
    }
    return result;
}
```

[1128. 等价多米诺骨牌对的数量](https://leetcode.cn/problems/number-of-equivalent-domino-pairs/)

```
int numEquivDominoPairs(vector<vector<int>> &dominoes) {
    int result = 0;
    map<pair<int, int>, int> map;
    for (const auto &domino: dominoes) {
        int first = min(domino[0], domino[1]);
        int second = max(domino[0], domino[1]);
        pair<int, int> p = make_pair(first, second);
        result += map[p];
        map[p]++;
    }
    return result;
}
```

[121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

```
int maxProfit(vector<int> &prices) {
    int minimum = INT_MAX;
    int profit = 0;
    for (const auto &price: prices) {
        profit = max(profit, price - minimum);
        minimum = min(minimum, price);
    }
    return profit;
}
```

[2016. 增量元素之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-increasing-elements/)

```
int maximumDifference(vector<int> &nums) {
    int result = 0;
    int minimum = INT_MAX;
    for (const auto &num: nums) {
        result = max(result, num - minimum);
        minimum = min(minimum, num);
    }
    return result ? result : -1;
}
```

[219. 存在重复元素 II](https://leetcode.cn/problems/contains-duplicate-ii/)

```
bool containsNearbyDuplicate(vector<int> &nums, int k) {
    unordered_map<int, int> map;
    for (int i = 0; i < nums.size(); i++) {
        if (map.contains(nums[i]) && i - map[nums[i]] <= k) {
            return true;
        }
        map[nums[i]] = i;
    }
    return false;
}
```

[2260. 必须拿起的最小连续卡牌数](https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/)

```
int minimumCardPickup(vector<int> &cards) {
    int result = INT_MAX;
    unordered_map<int, int> map;
    for (int i = 0; i < cards.size(); i++) {
        if (map.contains(cards[i])) {
            result = min(result, i - map[cards[i]] + 1);
        }
        map[cards[i]] = i;
    }
    return result != INT_MAX ? result : -1;
}
```

[2815. 数组中的最大数对和](https://leetcode.cn/problems/max-pair-sum-in-an-array/)

```
int maxSum(vector<int> &nums) {
    const auto maxDigit = [](int num) {
        int result = 0;
        while (num) {
            result = max(result, num % 10);
            num /= 10;
        }
        return result;
    };
    int result = -1;
    vector<int> maximum(10, INT_MIN);
    for (const auto &num: nums) {
        int digit = maxDigit(num);
        result = max(result, num + maximum[digit]);
        maximum[digit] = max(maximum[digit], num);
    }
    return result;
}
```

[2342. 数位和相等数对的最大和](https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/)

```
int maximumSum(vector<int> &nums) {
    const auto sumOfDigits = [](int num) {
        int result = 0;
        while (num) {
            result += num % 10;
            num /= 10;
        }
        return result;
    };
    int result = -1;
    unordered_map<int, int> map;
    for (int i = 0; i < nums.size(); i++) {
        int sum = sumOfDigits(nums[i]);
        if (map.contains(sum)) {
            result = max(result, nums[i] + map[sum]);
        }
        map[sum] = max(map[sum], nums[i]);
    }
    return result;
}
```

[1679. K 和数对的最大数目](https://leetcode.cn/problems/max-number-of-k-sum-pairs/)

```
int maxOperations(vector<int> &nums, int k) {
    int result = 0;
    unordered_map<int, int> map;
    for (const auto &num: nums) {
        if (map.contains(k - num)) {
            result++;
            map[k - num]--;
            if (map[k - num] == 0) {
                map.erase(k - num);
            }
        } else {
            map[num]++;
        }
    }
    return result;
}
```

[面试题 16.24. 数对和](https://leetcode.cn/problems/pairs-with-sum-lcci/)

```
vector<vector<int>> pairSums(vector<int> &nums, int target) {
    vector<vector<int>> result;
    unordered_map<int, int> map;
    for (const auto &num: nums) {
        if (map.contains(target - num)) {
            result.push_back({target - num, num});
            map[target - num]--;
            if (map[target - num] == 0) {
                map.erase(target - num);
            }
        } else {
            map[num]++;
        }
    }
    return result;
}
```

[3623. 统计梯形的数目 I](https://leetcode.cn/problems/count-number-of-trapezoids-i/)

```
int countTrapezoids(vector<vector<int>> &points) {
    unordered_map<int, int> map;
    for (const auto &point: points) {
        map[point[1]]++;
    }
    const int MOD = 1e9 + 7;
    long long result = 0;
    long long sum = 0;
    for (const auto &p: map) {
        long long k = 1LL * p.second * (p.second - 1) / 2;
        result += (k * sum);
        sum += k;
    }
    return static_cast<int>(result % MOD);
}
```

[3371. 识别数组中的最大异常值](https://leetcode.cn/problems/identify-the-largest-outlier-in-an-array/)

```
int getLargestOutlier(vector<int> &nums) {
    int sum = 0;
    unordered_map<int, int> map;
    for (const auto &num: nums) {
        sum += num;
        map[num]++;
    }

    int result = INT_MIN;
    for (const auto &num: nums) {
        if (map.contains(sum - 2 * num) && (num != sum - 2 * num || map[sum - 2 * num] > 1)) {
            result = max(result, sum - 2 * num);
        }
    }
    return result;
}
```

[624. 数组列表中的最大距离](https://leetcode.cn/problems/maximum-distance-in-arrays/)

```
int maxDistance(vector<vector<int>> &arrays) {
    int result = 0;
    int maximum = INT_MIN / 2;
    int minimum = INT_MAX / 2;
    for (const auto &array: arrays) {
        result = max({result, array.back() - minimum, maximum - array.front()});
        maximum = max(maximum, array.back());
        minimum = min(minimum, array.front());
    }
    return result;
}
```

[2364. 统计坏数对的数目](https://leetcode.cn/problems/count-number-of-bad-pairs/)

```
long long countBadPairs(vector<int> &nums) {
    long long result = 0;
    unordered_map<int, int> map;
    for (int i = 0; i < nums.size(); i++) {
        result += i - map[nums[i] - i];
        map[nums[i] - i]++;
    }
    return result;
}
```

[1014. 最佳观光组合](https://leetcode.cn/problems/best-sightseeing-pair/)

```
int maxScoreSightseeingPair(vector<int> &values) {
    int result = 0;
    int maximum = INT_MIN;
    for (int i = 0; i < values.size(); i++) {
        result = max(result, maximum + values[i] - i);
        maximum = max(maximum, values[i] + i);
    }
    return result;
}
```

[1814. 统计一个数组中好对子的数目](https://leetcode.cn/problems/count-nice-pairs-in-an-array/)

```
int countNicePairs(vector<int> &nums) {
    const auto rev = [](int num) {
        int result = 0;
        while (num) {
            result = 10 * result + num % 10;
            num /= 10;
        }
        return result;
    };

    const long long MOD = 1e9 + 7;
    long long result = 0;
    unordered_map<int, int> map;
    for (const auto &num: nums) {
        int r = rev(num);
        result += map[num - r];
        map[num - r]++;
    }
    return static_cast<int>(result % MOD);
}
```

[3584. 子序列首尾元素的最大乘积](https://leetcode.cn/problems/maximum-product-of-first-and-last-elements-of-a-subsequence/)

```
long long maximumProduct(vector<int> &nums, int m) {
    long long result = LLONG_MIN;
    int maximum = INT_MIN;
    int minimum = INT_MAX;
    for (int i = m - 1; i < nums.size(); i++) {
        maximum = max(maximum, nums[i - m + 1]);
        minimum = min(minimum, nums[i - m + 1]);
        result = max({result, 1LL * nums[i] * maximum, 1LL * nums[i] * minimum});
    }
    return result;
}
```

[2905. 找出满足差值条件的下标 II](https://leetcode.cn/problems/find-indices-with-index-and-value-difference-ii/)

```
vector<int> findIndices(vector<int> &nums, int indexDifference, int valueDifference) {
    int maximum = 0;
    int minimum = 0;
    for (int i = indexDifference; i < nums.size(); i++) {
        maximum = nums[maximum] >= nums[i - indexDifference] ? maximum : i - indexDifference;
        minimum = nums[minimum] <= nums[i - indexDifference] ? minimum : i - indexDifference;
        if (nums[i] - nums[minimum] >= valueDifference) {
            return {i, minimum};
        }
        if (nums[maximum] - nums[i] >= valueDifference) {
            return {i, maximum};
        }
    }
    return {-1, -1};
}
```

#### 维护左右枚举中间

- 维护左右枚举中间的好处是减少代码复杂度（不用显式地处理位置关系）
- 根据题目要求确定最大/最小/数量的前缀/后缀数组

[2909. 元素和最小的山形三元组 II](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/)

```
int minimumSum(vector<int> &nums) {
    vector<int> prefix(nums.size());
    prefix[0] = nums.front();
    for (int i = 1; i < nums.size(); i++) {
        prefix[i] = min(prefix[i - 1], nums[i]);
    }

    vector<int> suffix(nums.size());
    suffix[suffix.size() - 1] = nums.back();
    for (int i = nums.size() - 2; i >= 0; i--) {
        suffix[i] = min(suffix[i + 1], nums[i]);
    }

    int result = INT_MAX;
    for (int i = 1; i < nums.size() - 1; i++) {
        if (prefix[i - 1] < nums[i] && nums[i] > suffix[i + 1]) {
            result = min(result, prefix[i - 1] + nums[i] + suffix[i + 1]);
        }
    }
    return result != INT_MAX ? result : -1;
}
```

[3583. 统计特殊三元组](https://leetcode.cn/problems/count-special-triplets/)

```
int specialTriplets(vector<int> &nums) {
    unordered_map<int, int> suffix;
    for (const auto &num: nums) {
        suffix[num]++;
    }

    const long long MOD = 1e9 + 7;
    long long result = 0;
    unordered_map<int, int> prefix;
    for (const auto &num: nums) {
        suffix[num]--;
        result += 1LL * prefix[num * 2] * suffix[num * 2];
        prefix[num]++;
    }
    return static_cast<int>(result % MOD);
}
```

[1930. 长度为 3 的不同回文子序列](https://leetcode.cn/problems/unique-length-3-palindromic-subsequences/)

```
int countPalindromicSubsequence(string s) {
    vector<int> suffix(26);
    for (const auto &c: s) {
        suffix[c - 'a']++;
    }

    vector<int> count(26);
    vector<int> prefix(26);
    for (const auto &c: s) {
        suffix[c - 'a']--;
        for (int j = 0; j < 26; j++) {
            if (prefix[j] && suffix[j]) {
                count[c - 'a'] |= (1 << j);
            }
        }
        prefix[c - 'a']++;
    }
    int result = 0;
    for (const auto &c: count) {
        result += __builtin_popcount(c);
    }
    return result;
}
```

[3128. 直角三角形](https://leetcode.cn/problems/right-triangles/)

```
long long numberOfRightTriangles(vector<vector<int>> &grid) {
    vector<int> row(grid.size());
    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[i].size(); j++) {
            if (grid[i][j]) {
                row[i]++;
            }
        }
    }
    vector<int> column(grid[0].size());
    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[i].size(); j++) {
            if (grid[i][j]) {
                column[j]++;
            }
        }
    }
    long long result = 0;
    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[i].size(); j++) {
            if (grid[i][j]) {
                result += (row[i] - 1) * (column[j] - 1);
            }
        }
    }
    return result;
}
```

[2874. 有序三元组中的最大值 II](https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/)

```
long long maximumTripletValue(vector<int> &nums) {
    vector<int> prefix(nums.size());
    prefix[0] = nums.front();
    for (int i = 1; i < nums.size(); i++) {
        prefix[i] = max(prefix[i - 1], nums[i]);
    }

    vector<int> suffix(nums.size());
    suffix[suffix.size() - 1] = nums.back();
    for (int i = nums.size() - 2; i >= 0; i--) {
        suffix[i] = max(suffix[i + 1], nums[i]);
    }

    long long result = 0;
    for (int i = 1; i < nums.size() - 1; i++) {
        result = max(result, 1LL * (prefix[i - 1] - nums[i]) * suffix[i + 1]);
    }
    return result;
}
```

[447. 回旋镖的数量](https://leetcode.cn/problems/number-of-boomerangs/)

```
int numberOfBoomerangs(vector<vector<int>> &points) {
    const auto distance = [](const vector<int> &a, const vector<int> &b) {
        return pow(b[0] - a[0], 2) + pow(b[1] - a[1], 2);
    };
    int result = 0;
    for (int i = 0; i < points.size(); i++) {
        unordered_map<int, int> map;
        for (int j = 0; j < points.size(); j++) {
            map[distance(points[i], points[j])]++;
        }
        for (const auto &p: map) {
            result += p.second * (p.second - 1);
        }
    }
    return result;
}
```

### 前缀和

#### 前缀和

[303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

```
class NumArray {
private:
    vector<int> buffer;

public:
    NumArray(vector<int> &nums) {
        buffer.resize(nums.size() + 1);
        for (int i = 0; i < nums.size(); i++) {
            buffer[i + 1] = nums[i] + buffer[i];
        }
    }

    int sumRange(int left, int right) {
        return buffer[right + 1] - buffer[left];
    }
};
```

[3427. 变长子数组求和](https://leetcode.cn/problems/sum-of-variable-length-subarrays/)

```
int subarraySum(vector<int> &nums) {
    int result = 0;
    vector<int> buffer(nums.size() + 1);
    for (int i = 0; i < nums.size(); i++) {
        buffer[i + 1] = buffer[i] + nums[i];
        result += buffer[i + 1] - buffer[max(0, i - nums[i])];
    }
    return result;
}
```

[2559. 统计范围内的元音字符串数](https://leetcode.cn/problems/count-vowel-strings-in-ranges/)

```
vector<int> vowelStrings(vector<string> &words, vector<vector<int>> &queries) {
    const auto isVowel = [](const char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
    };
    vector<int> vowels(words.size() + 1);
    for (int i = 0; i < words.size(); i++) {
        vowels[i + 1] = vowels[i] + (isVowel(words[i].front()) && isVowel(words[i].back()));
    }
    vector<int> result(queries.size());
    for (int i = 0; i < queries.size(); i++) {
        result[i] = vowels[queries[i][1] + 1] - vowels[queries[i][0]];
    }
    return result;
}
```

[3152. 特殊数组 II](https://leetcode.cn/problems/special-array-ii/)

```
vector<bool> isArraySpecial(vector<int> &nums, vector<vector<int>> &queries) {
    vector<int> sum(nums.size());
    for (int i = 1; i < nums.size(); i++) {
        sum[i] = sum[i - 1] + (nums[i - 1] % 2 == nums[i] % 2);
    }

    vector<bool> result(queries.size());
    for (int i = 0; i < queries.size(); i++) {
        result[i] = sum[queries[i][0]] == sum[queries[i][1]];
    }
    return result;
}
```

[1749. 任意子数组和的绝对值的最大值](https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/)

```
int maxAbsoluteSum(vector<int> &nums) {
    int sum = 0;
    int maximum = 0;
    int minimum = 0;
    for (const auto &num: nums) {
        sum += num;
        maximum = max(maximum, sum);
        minimum = min(minimum, sum);
    }
    return maximum - minimum;
}
```

[3652. 按策略买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-using-strategy/)

```
long long maxProfit(vector<int> &prices, vector<int> &strategy, int k) {
    vector<int> sum1(prices.size() + 1);
    vector<int> sum2(prices.size() + 1);
    for (int i = 0; i < prices.size(); i++) {
        sum1[i + 1] = sum1[i] + prices[i] * strategy[i];
        sum2[i + 1] = sum2[i] + prices[i];
    }
    long long result = sum1[prices.size()];
    for (int i = k; i < sum1.size(); i++) {
        result = max(result, 1LL * sum1[i - k] + sum1[prices.size()] - sum1[i] + sum2[i] - sum2[i - k / 2]);
    }
    return result;
}
```

[2389. 和有限的最长子序列](https://leetcode.cn/problems/longest-subsequence-with-limited-sum/)

```
vector<int> answerQueries(vector<int> &nums, vector<int> &queries) {
    sort(nums.begin(), nums.end());
    vector<int> sum(nums.size() + 1);
    for (int i = 0; i < nums.size(); i++) {
        sum[i + 1] = sum[i] + nums[i];
    }
    vector<int> result(queries.size());
    for (int i = 0; i < queries.size(); i++) {
        result[i] = upper_bound(sum.begin(), sum.end(), queries[i]) - sum.begin() - 1;
    }
    return result;
}
```

[3361. 两个字符串的切换距离](https://leetcode.cn/problems/shift-distance-between-two-strings/)

```
long long shiftDistance(string s, string t, vector<int> &nextCost, vector<int> &previousCost) {
    vector<long long> next(26 + 1);
    long long sum1 = 0;
    vector<long long> prev(26 + 1);
    long long sum2 = 0;
    for (int i = 0; i < 26; i++) {
        next[i + 1] = next[i] + nextCost[i];
        sum1 += nextCost[i];
        prev[i + 1] = prev[i] + previousCost[i];
        sum2 += previousCost[i];
    }

    long long result = 0;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] < t[i]) {
            result += min(next[t[i] - 'a'] - next[s[i] - 'a'], sum2 - (prev[t[i] - 'a' + 1] - prev[s[i] - 'a' + 1]));
        } else if (s[i] > t[i]) {
            result += min(sum1 - (next[s[i] - 'a'] - next[t[i] - 'a']), prev[s[i] - 'a' + 1] - prev[t[i] - 'a' + 1]);
        }
    }
    return result;
}
```

#### 前缀和与哈希表

- 求连续子数组之和问题可以转化为前缀和之差即：$N[i]+N[i+1]+...+N[j-1]+N[j]=S[j]-S[i]=T$
- 利用维护左枚举右技巧，使用哈希表查找$S[i]$

[930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/)

```
int numSubarraysWithSum(vector<int> &nums, int goal) {
    int result = 0;
    unordered_map<int, int> map;
    map[0] = 1;
    int sum = 0;
    for (const auto &num: nums) {
        sum += num;
        result += map[sum - goal];
        map[sum]++;
    }
    return result;
}
```

[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

```
int subarraySum(vector<int> &nums, int k) {
    int result = 0;
    unordered_map<int, int> map;
    map[0] = 1;
    int sum = 0;
    for (const auto &num: nums) {
        sum += num;
        result += map[sum - k];
        map[sum]++;
    }
    return result;
}
```

[1524. 和为奇数的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/)

```
int numOfSubarrays(vector<int> &arr) {
    const int MOD = 1e9 + 7;
    int result = 0;
    vector<int> count(2);
    count[0] = 1;
    int sum = 0;
    for (const auto &num: arr) {
        sum += num;
        result = (result + count[sum % 2 ^ 1]) % MOD;
        count[sum % 2]++;
    }
    return result;
}
```

[974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)

```
int subarraysDivByK(vector<int> &nums, int k) {
    int result = 0;
    unordered_map<int, int> map;
    map[0] = 1;
    int sum = 0;
    for (const auto &num: nums) {
        sum += num;
        result += map[(sum % k + k) % k];
        map[(sum % k + k) % k]++;
    }
    return result;
}
```

[523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/)

```
bool checkSubarraySum(vector<int> &nums, int k) {
    unordered_map<int, int> map;
    map[0] = -1;
    int sum = 0;
    for (int i = 0; i < nums.size(); i++) {
        sum += nums[i];
        if (map.contains(sum % k)) {
            if (i - map[sum % k] >= 2) {
                return true;
            }
        } else {
            map[sum % k] = i;
        }
    }
    return false;
}
```

[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

```
long long dfs(TreeNode *root, long long sum) {
    if (root) {
        if (sum == root->val) {
            return 1 + dfs(root->left, sum - root->val) + dfs(root->right, sum - root->val);
        } else {
            return dfs(root->left, sum - root->val) + dfs(root->right, sum - root->val);
        }
    } else {
        return 0;
    }
}

int pathSum(TreeNode *root, int sum) {
    return root ? dfs(root, sum) + pathSum(root->left, sum) + pathSum(root->right, sum) : 0;
}
```

[2588. 统计美丽子数组数目](https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/)

```
long long beautifulSubarrays(vector<int> &nums) {
    long long result = 0;
    unordered_map<int, int> map;
    map[0] = 1;
    int sum;
    for (const auto &num: nums) {
        sum ^= num;
        result += map[sum];
        map[sum]++;
    }
    return result;
}
```

[525. 连续数组](https://leetcode.cn/problems/contiguous-array/)

```
int findMaxLength(vector<int> &nums) {
    int result = 0;
    unordered_map<int, int> map;
    map[0] = -1;
    int sum = 0;
    for (int i = 0; i < nums.size(); i++) {
        sum += (nums[i] == 1 ? nums[i] : -1);
        if (map.contains(sum)) {
            result = max(result, i - map[sum]);
        } else {
            map[sum] = i;
        }
    }
    return result;
}
```

[面试题 17.05. 字母与数字](https://leetcode.cn/problems/find-longest-subarray-lcci/)

```
vector<string> findLongestSubarray(vector<string> &array) {
    unordered_map<int, int> map;
    map[0] = -1;
    int sum = 0;
    int begin = -1;
    int length = 0;
    for (int i = 0; i < array.size(); i++) {
        sum += (isdigit(array[i][0]) ? 1 : -1);
        if (map.contains(sum)) {
            if (i - map[sum] > length) {
                length = i - map[sum];
                begin = map[sum] + 1;
            }
        } else {
            map[sum] = i;
        }
    }
    return length ? vector<string>(array.begin() + begin, array.begin() + begin + length) : vector<string>();
}
```

#### 前缀和与有序集合

[3364. 最小正和子数组](https://leetcode.cn/problems/minimum-positive-sum-subarray/)

```
int minimumSumSubarray(vector<int> &nums, int l, int r) {
    int result = INT_MAX;
    vector<int> sum(nums.size() + 1);
    for (int i = 0; i < nums.size(); i++) {
        sum[i + 1] = sum[i] + nums[i];
    }
    int left = 0;
    int right = 1;
    while (right < sum.size()) {
        while (right - left > r) {
            left++;
        }
        for (int i = left; i < right; i++) {
            if (right - i >= l && sum[right] - sum[i] > 0) {
                result = min(result, sum[right] - sum[i]);
            }
        }
        right++;
    }
    return result != INT_MAX ? result : -1;
}
```

[363. 矩形区域不超过 K 的最大数值和](https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k/)

```
int maxSumSubmatrix(vector<vector<int>> &matrix, int k) {
    int result = INT_MIN;
    for (int i = 0; i < matrix.size(); i++) {
        vector<int> sum(matrix[i].size());
        for (int j = i; j < matrix.size(); j++) {
            for (int k = 0; k < matrix[i].size(); k++) {
                sum[k] += matrix[j][k];
            }
            set<int> set;
            set.insert(0);
            int s = 0;
            for (const auto &num: sum) {
                s += num;
                auto l = set.lower_bound(s - k);
                if (l != set.end()) {
                    result = max(result, s - *l);
                }
                set.insert(s);
            }
        }
    }
    return result;
}
```

#### 距离和

对于距离和题目，即求$\sum_{j=0}^{m-1}|nums[i]-nums[j]|$，算法如下：

- 求$nums[0...m-1]$的前缀和$prefix$，其中$prefix[0]=0$

- 对于左边元素`j < k`：$left=\sum_{j=0}^{k-1}(nums[i]-nums[j])=k*nums[i]-prefix[k]$
- 对于右边元素`j > k`：$right=\sum_{j=k+1}^{m-1}(nums[j]-nums[i])=(prefix[m]-prefix[k+1])-(m-(k+1))*nums[i]$
- 距离和为：$result=left+right$

[1685. 有序数组中差绝对值之和](https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/)

```
vector<int> getSumAbsoluteDifferences(vector<int> &nums) {
    vector<int> sum(nums.size() + 1);
    for (int i = 0; i < nums.size(); i++) {
        sum[i + 1] = sum[i] + nums[i];
    }
    vector<int> result(nums.size());
    for (int i = 0; i < nums.size(); i++) {
        int left = i * nums[i] - sum[i];
        int right = sum[nums.size()] - sum[i + 1] - (nums.size() - (i + 1)) * nums[i];
        result[i] = left + right;
    }
    return result;
}
```

[2615. 等值距离和](https://leetcode.cn/problems/sum-of-distances/)

```
vector<long long> distance(vector<int> &nums) {
    unordered_map<int, vector<int>> map;
    for (int i = 0; i < nums.size(); i++) {
        map[nums[i]].emplace_back(i);
    }
    vector<long long> result(nums.size());
    for (const auto &p: map) {
        vector<long long> sum(p.second.size() + 1);
        for (int i = 0; i < p.second.size(); i++) {
            sum[i + 1] = sum[i] + p.second[i];
        }
        for (int i = 0; i < p.second.size(); i++) {
            long long left = 1LL * p.second[i] * i - sum[i];
            long long right = sum[p.second.size()] - sum[i + 1] - (p.second.size() - (i + 1)) * p.second[i];
            result[p.second[i]] = left + right;
        }
    }
    return result;
}
```

[2602. 使数组元素全部相等的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/)

```
vector<long long> minOperations(vector<int> &nums, vector<int> &queries) {
    sort(nums.begin(), nums.end());
    vector<long long> sum(nums.size() + 1);
    for (int i = 0; i < nums.size(); i++) {
        sum[i + 1] = sum[i] + nums[i];
    }
    vector<long long> result(queries.size());
    for (int i = 0; i < queries.size(); i++) {
        int index = lower_bound(nums.begin(), nums.end(), queries[i]) - nums.begin();
        long long left = 1LL * index * queries[i] - sum[index];
        long long right = sum[nums.size()] - sum[index] - (nums.size() - index) * queries[i];
        result[i] = left + right;
    }
    return result;
}
```

#### 前缀异或和

[1310. 子数组异或查询](https://leetcode.cn/problems/xor-queries-of-a-subarray/)

```
vector<int> xorQueries(vector<int> &arr, vector<vector<int>> &queries) {
    vector<int> sum(arr.size() + 1);
    for (int i = 0; i < arr.size(); i++) {
        sum[i + 1] = sum[i] ^ arr[i];
    }
    vector<int> result(queries.size());
    for (int i = 0; i < queries.size(); i++) {
        result[i] = sum[queries[i][0]] ^ sum[queries[i][1] + 1];
    }
    return result;
}
```

#### 一维前缀和

[1177. 构建回文串检测](https://leetcode.cn/problems/can-make-palindrome-from-substring/)

```
vector<bool> canMakePaliQueries(string s, vector<vector<int>> &queries) {
    vector<vector<int>> sum(s.length() + 1, vector<int>(26));
    for (int i = 0; i < s.length(); i++) {
        sum[i + 1] = sum[i];
        sum[i + 1][s[i] - 'a']++;
    }
    vector<bool> result(queries.size());
    for (int i = 0; i < queries.size(); i++) {
        int s = 0;
        for (int j = 0; j < 26; j++) {
            s += (sum[queries[i][1] + 1][j] - sum[queries[i][0]][j]) % 2;
        }
        result[i] = s / 2 <= queries[i][2];
    }
    return result;
}
```

#### 二维前缀和

[304. 二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

```
class NumMatrix {
private:
    vector<vector<int>> sum;

public:
    NumMatrix(vector<vector<int>> &matrix) {
        sum = vector<vector<int>>(matrix.size() + 1,
                                  vector<int>(matrix[0].size() + 1));
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[i].size(); j++) {
                sum[i + 1][j + 1] =
                        matrix[i][j] + sum[i + 1][j] + sum[i][j + 1] - sum[i][j];
            }
        }
    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        return sum[row2 + 1][col2 + 1] - sum[row2 + 1][col1] - sum[row1][col2 + 1] + sum[row1][col1];
    }
};
```

[1314. 矩阵区域和](https://leetcode.cn/problems/matrix-block-sum/)

```
vector<vector<int>> matrixBlockSum(vector<vector<int>> &mat, int k) {
    vector<vector<int>> sum(mat.size() + 1, vector<int>(mat[0].size() + 1));
    for (int i = 0; i < mat.size(); i++) {
        for (int j = 0; j < mat[i].size(); j++) {
            sum[i + 1][j + 1] = mat[i][j] + sum[i + 1][j] + sum[i][j + 1] - sum[i][j];
        }
    }
    vector<vector<int>> result(mat.size(), vector<int>(mat[0].size()));
    for (int i = 0; i < mat.size(); i++) {
        for (int j = 0; j < mat[i].size(); j++) {
            int row1 = i - k >= 0 ? i - k : 0;
            int col1 = j - k >= 0 ? j - k : 0;
            int row2 = i + k < mat.size() ? i + k : mat.size() - 1;
            int col2 = j + k < mat[0].size() ? j + k : mat[0].size() - 1;
            result[i][j] = sum[row2 + 1][col2 + 1] - sum[row2 + 1][col1] - sum[row1][col2 + 1] + sum[row1][col1];
        }
    }
    return result;
}
```

[3070. 元素和小于等于 k 的子矩阵的数目](https://leetcode.cn/problems/count-submatrices-with-top-left-element-and-sum-less-than-k/)

```
int countSubmatrices(vector<vector<int>> &grid, int k) {
    vector<vector<int>> sum(grid.size() + 1, vector<int>(grid[0].size() + 1));
    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[i].size(); j++) {
            sum[i + 1][j + 1] = grid[i][j] + sum[i + 1][j] + sum[i][j + 1] - sum[i][j];
        }
    }
    int result = 0;
    for (int i = 1; i < sum.size(); i++) {
        for (int j = 1; j < sum[i].size(); j++) {
            if (sum[i][j] <= k) {
                result++;
            }
        }
    }
    return result;
}
```

[1738. 找出第 K 大的异或坐标值](https://leetcode.cn/problems/find-kth-largest-xor-coordinate-value/)

```
int kthLargestValue(vector<vector<int>> &matrix, int k) {
    vector<vector<int>> sum(matrix.size() + 1, vector<int>(matrix[0].size() + 1));
    for (int i = 0; i < matrix.size(); i++) {
        for (int j = 0; j < matrix[i].size(); j++) {
            sum[i + 1][j + 1] = matrix[i][j] ^ sum[i + 1][j] ^ sum[i][j + 1] ^ sum[i][j];
        }
    }
    priority_queue<int> pq;
    for (int i = 1; i < sum.size(); i++) {
        for (int j = 1; j < sum[i].size(); j++) {
            pq.push(sum[i][j]);
        }
    }
    for (int i = 0; i < k - 1; i++) {
        pq.pop();
    }
    return pq.top();
}
```

[3212. 统计 X 和 Y 频数相等的子矩阵数量](https://leetcode.cn/problems/count-submatrices-with-equal-frequency-of-x-and-y/)

```
int numberOfSubmatrices(vector<vector<char>> &grid) {
    vector<vector<vector<int>>> sum(grid.size() + 1, vector<vector<int>>(grid[0].size() + 1, vector<int>(2)));
    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[i].size(); j++) {
            int count = 0;
            if (grid[i][j] != '.') {
                if (grid[i][j] == 'X') {
                    count = 1;
                } else {
                    count = -1;
                }
            }
            sum[i + 1][j + 1][0] = count + sum[i + 1][j][0] + sum[i][j + 1][0] - sum[i][j][0];
            sum[i + 1][j + 1][1] = (count == 1) || sum[i + 1][j][1] || sum[i][j + 1][1];
        }
    }

    int result = 0;
    for (int i = 1; i < sum.size(); i++) {
        for (int j = 1; j < sum[i].size(); j++) {
            if (sum[i][j][0] == 0 && sum[i][j][1]) {
                result++;
            }
        }
    }
    return result;
}
```

### 差分

给定一个长度为$n$的数组$nums$，我们可以通过一个长度为$n$的差分数组$diff$来表示$nums$的变化：

- 差分数组： $diff[i]=a[i]−a[i−1]，diff[0]=a[0]$
- 修改区间$[l,r]$：$diff[l]+=v,diff[r+1]-=v$
- 还原数组：$a[i]=a[i−1]+diff[i]$

#### 一维差分

[2848. 与车相交的点](https://leetcode.cn/problems/points-that-intersect-with-cars/)

```
int numberOfPoints(vector<vector<int>> &nums) {
    vector<int> diff(101);
    for (const auto &num: nums) {
        diff[num[0]] += 1;
        if (num[1] + 1 < diff.size()) {
            diff[num[1] + 1] -= 1;
        }
    }
    int result = 0;
    int n = 0;
    for (const auto &d: diff) {
        n += d;
        if (n > 0) {
            result++;
        }
    }
    return result;
}
```

[1893. 检查是否区域内所有整数都被覆盖](https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered/)

```
bool isCovered(vector<vector<int>> &ranges, int left, int right) {
    vector<int> diff(51);
    for (const auto &range: ranges) {
        diff[range[0]] += 1;
        if (range[1] + 1 < diff.size()) {
            diff[range[1] + 1] -= 1;
        }
    }

    bool cover = true;
    int r = 0;
    for (int i = 0; i < diff.size(); i++) {
        r += diff[i];
        if (i >= left && i <= right) {
            cover = r > 0;
        }
        if (!cover) {
            return false;
        }
    }
    return true;
}
```

[1854. 人口最多的年份](https://leetcode.cn/problems/maximum-population-year/)

```
int maximumPopulation(vector<vector<int>> &logs) {
    vector<int> diff(101);
    for (const auto &log: logs) {
        diff[log[0] - 1950] += 1;
        if (log[1] - 1950 < diff.size()) {
            diff[log[1] - 1950] -= 1;
        }
    }
    int result = 0;
    int maximum = 0;
    int l = 0;
    for (int i = 0; i < diff.size(); i++) {
        l += diff[i];
        if (l > maximum) {
            maximum = l;
            result = i + 1950;
        }
    }
    return result;
}
```

[2960. 统计已测试设备](https://leetcode.cn/problems/count-tested-devices-after-test-operations/)

```
int countTestedDevices(vector<int> &batteryPercentages) {
    int result = 0;
    for (int i = 0; i < batteryPercentages.size(); i++) {
        if (batteryPercentages[i] > 0) {
            result++;
            for (int j = i + 1; j < batteryPercentages.size(); j++) {
                batteryPercentages[j]--;
            }
        }
    }
    return result;
}
```

[1094. 拼车](https://leetcode.cn/problems/car-pooling/)

```
bool carPooling(vector<vector<int>> &trips, int capacity) {
    vector<int> diff(1001);
    for (const auto &trip: trips) {
        diff[trip[1]] += trip[0];
        diff[trip[2]] -= trip[0];
    }
    int c = 0;
    for (const auto &d: diff) {
        c += d;
        if (c > capacity) {
            return false;
        }
    }
    return true;
}
```

[1109. 航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)

```
vector<int> corpFlightBookings(vector<vector<int>> &bookings, int n) {
    vector<int> diff(n);
    for (const auto &booking: bookings) {
        diff[booking[0] - 1] += booking[2];
        if (booking[1] < n) {
            diff[booking[1]] -= booking[2];
        }
    }
    vector<int> result(n);
    result[0] = diff[0];
    for (int i = 1; i < diff.size(); i++) {
        result[i] = result[i - 1] + diff[i];
    }
    return result;
}
```

[3355. 零数组变换 I](https://leetcode.cn/problems/zero-array-transformation-i/)

```
bool isZeroArray(vector<int> &nums, vector<vector<int>> &queries) {
    vector<int> diff(nums.size());
    diff[0] = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        diff[i] = nums[i] - nums[i - 1];
    }
    for (const auto &query: queries) {
        diff[query[0]] -= 1;
        if (query[1] + 1 < diff.size()) {
            diff[query[1] + 1] += 1;
        }
    }
    int sum = 0;
    for (const auto &d: diff) {
        sum += d;
        if (sum > 0) {
            return false;
        }
    }
    return true;
}
```

#### 二维差分

[2536. 子矩阵元素加 1](https://leetcode.cn/problems/increment-submatrices-by-one/)

```
vector<vector<int>> rangeAddQueries(int n, vector<vector<int>> &queries) {
    vector<vector<int>> diff(n, vector<int>(n));
    for (const auto &query: queries) {
        int r1 = query[0];
        int c1 = query[1];
        int r2 = query[2];
        int c2 = query[3];
        diff[r1][c1] += 1;
        if (r2 + 1 < n) {
            diff[r2 + 1][c1] -= 1;
        }
        if (c2 + 1 < n) {
            diff[r1][c2 + 1] -= 1;
        }
        if (r2 + 1 < n && c2 + 1 < n) {
            diff[r2 + 1][c2 + 1] += 1;
        }
    }
    vector<vector<int>> result(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            result[i][j] = diff[i][j];
            if (i > 0) {
                result[i][j] += result[i - 1][j];
            }
            if (j > 0) {
                result[i][j] += result[i][j - 1];
            }
            if (i > 0 && j > 0) {
                result[i][j] -= result[i - 1][j - 1];
            }
        }
    }
    return result;
}
```

### 栈

#### 栈

[1441. 用栈操作构建数组](https://leetcode.cn/problems/build-an-array-with-stack-operations/)

```
vector<string> buildArray(vector<int> &target, int n) {
    vector<string> result;
    int i = 0;
    for (int j = 1; j <= n && i < target.size(); j++) {
        if (j == target[i]) {
            result.push_back("Push");
            i++;
        } else {
            result.push_back("Push");
            result.push_back("Pop");
        }
    }
    return result;
}
```

[844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

```
bool backspaceCompare(string s, string t) {
    const auto transform = [](string s) {
        string result;
        for (const auto &c: s) {
            if (c != '#') {
                result.push_back(c);
            } else {
                if (!result.empty()) {
                    result.pop_back();
                }
            }
        }
        return result;
    };
    return transform(s) == transform(t);
}
```

[682. 棒球比赛](https://leetcode.cn/problems/baseball-game/)

```
int calPoints(vector<string> &operations) {
    stack<int> stack;
    for (const auto &operation: operations) {
        if (operation == "+") {
            int num2 = stack.top();
            stack.pop();
            int num1 = stack.top();
            stack.push(num2);
            stack.push(num1 + num2);
        } else if (operation == "D") {
            stack.push(stack.top() * 2);
        } else if (operation == "C") {
            stack.pop();
        } else {
            stack.push(stoi(operation));
        }
    }
    int result = 0;
    while (!stack.empty()) {
        result += stack.top();
        stack.pop();
    }
    return result;
}
```

[2390. 从字符串中移除星号](https://leetcode.cn/problems/removing-stars-from-a-string/)

```
string removeStars(string s) {
    string result;
    for (const auto &c: s) {
        if (c != '*') {
            result.push_back(c);
        } else {
            if (!result.empty()) {
                result.pop_back();
            }
        }
    }
    return result;
}
```

[1472. 设计浏览器历史记录](https://leetcode.cn/problems/design-browser-history/)

```
class BrowserHistory {
private:
    int index;
    vector<string> history;

public:
    BrowserHistory(string homepage) {
        index = 0;
        history.push_back(homepage);
    }

    void visit(string url) {
        index++;
        history.resize(index);
        history.push_back(url);
    }

    string back(int steps) {
        index = index - steps >= 0 ? index - steps : 0;
        return history[index];
    }

    string forward(int steps) {
        index = index + steps < history.size() ? index + steps : history.size() - 1;
        return history[index];
    }
};
```

[946. 验证栈序列](https://leetcode.cn/problems/validate-stack-sequences/)

```
bool validateStackSequences(vector<int> &pushed, vector<int> &popped) {
    int i = 0;
    int j = 0;
    stack<int> stack;
    while (i < pushed.size() && j < popped.size()) {
        if (!stack.empty() && stack.top() == popped[j]) {
            stack.pop();
            j++;
        } else if (pushed[i] == popped[j]) {
            i++;
            j++;
        } else {
            stack.push(pushed[i]);
            i++;
        }
    }
    while (i < pushed.size()) {
        stack.push(pushed[i]);
        i++;
    }
    while (j < popped.size()) {
        if (stack.top() != popped[j]) {
            return false;
        } else {
            stack.pop();
            j++;
        }
    }
    return true;
}
```

[3412. 计算字符串的镜像分数](https://leetcode.cn/problems/find-mirror-score-of-a-string/)

```
long long calculateScore(string s) {
    const auto mirror = [](char c) { return 'a' + ('z' - c); };
    unordered_map<char, stack<int>> map;
    long long result = 0;
    for (long long i = 0; i < s.length(); i++) {
        char target = mirror(s[i]);
        if (map.contains(target)) {
            result += i - map[target].top();
            map[target].pop();
            if (map[target].empty()) {
                map.erase(target);
            }
        } else {
            map[s[i]].push(i);
        }
    }
    return result;
}
```

[71. 简化路径](https://leetcode.cn/problems/simplify-path/)

```
string simplifyPath(string path) {
    stack<string> stack;
    size_t begin = 0;
    size_t end = path.find('/', begin);
    while (end != string::npos) {
        string s = path.substr(begin, end - begin + 1);
        if (!s.empty()) {
            if (s == "/") {
                if (stack.empty()) {
                    stack.push(s);
                }
            } else if (s == "." || s == "./") {
            } else if (s == ".." || s == "../") {
                if (!stack.empty() && stack.top() != "/") {
                    stack.pop();
                }
            } else {
                stack.push(s);
            }
        }

        begin = end + 1;
        end = path.find('/', begin);
    }
    string s = path.substr(begin, end - begin + 1);
    if (!s.empty()) {
        if (s == "/") {
            if (stack.empty()) {
                stack.push(s);
            }
        } else if (s == "." || s == "./") {
        } else if (s == ".." || s == "../") {
            if (!stack.empty() && stack.top() != "/") {
                stack.pop();
            }
        } else {
            stack.push(s);
        }
    }

    if (stack.size() > 1 && stack.top().back() == '/') {
        string s = stack.top().substr(0, stack.top().length() - 1);
        stack.pop();
        stack.push(s);
    }

    string result;
    while (!stack.empty()) {
        result = stack.top() + result;
        stack.pop();
    }
    return result;
}
```

#### 消除邻项

[2696. 删除子串后的字符串最小长度](https://leetcode.cn/problems/minimum-string-length-after-removing-substrings/)

```
int minLength(string s) {
    string stack;
    for (const auto &c: s) {
        stack.push_back(c);
        if (stack.length() >= 2 && (stack.substr(stack.length() - 2, 2) == "AB" || stack.substr(stack.length() - 2, 2) == "CD")) {
            stack.pop_back();
            stack.pop_back();
        }
    }
    return stack.length();
}
```

[1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

```
string removeDuplicates(string s) {
    string stack;
    for (const auto &c: s) {
        if (!stack.empty() && stack.back() == c) {
            stack.pop_back();
        } else {
            stack.push_back(c);
        }

    }
    return stack;
}
```

[1544. 整理字符串](https://leetcode.cn/problems/make-the-string-great/)

```
string makeGood(string s) {
    string stack;
    for (const auto &c: s) {
        if (!stack.empty() && (islower(stack.back()) && toupper(stack.back()) == c || isupper(stack.back()) && tolower(stack.back()) == c)) {
            stack.pop_back();
        } else {
            stack.push_back(c);
        }
    }
    return stack;
}
```

[3561. 移除相邻字符](https://leetcode.cn/problems/resulting-string-after-adjacent-removals/)

```
string resultingString(string s) {
    string stack;
    for (const auto &c: s) {
        if (!stack.empty() && (stack.back() == (c - 'a' + 1) % 26 + 'a' || stack.back() == (c - 'a' - 1 + 26) % 26 + 'a')) {
            stack.pop_back();
        } else {
            stack.push_back(c);
        }
    }
    return stack;
}
```

[1003. 检查替换后的词是否有效](https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/)

```
bool isValid(string s) {
    string stack;
    for (const auto &c: s) {
        stack.push_back(c);
        if (stack.length() >= 3 && stack.substr(stack.length() - 3, 3) == "abc") {
            stack.erase(stack.length() - 3, 3);
        }
    }
    return stack.empty();
}
```

[2216. 美化数组的最少删除数](https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/)

```
int minDeletion(vector<int> &nums) {
    vector<int> stack;
    int i = 0;
    for (const auto &num: nums) {
        if (stack.size() % 2 == 0 || stack.back() != num) {
            stack.push_back(num);
        }
    }
    if (stack.size() % 2 == 1) {
        stack.pop_back();
    }
    return nums.size() - stack.size();
}
```

[1209. 删除字符串中的所有相邻重复项 II](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/)

```
string removeDuplicates(string s, int k) {
    string stack;
    for (const auto &c: s) {
        stack.push_back(c);
        if (stack.length() >= k && stack.substr(stack.length() - k, k) == string(k, c)) {
            stack.erase(stack.length() - k, k);
        }
    }
    return stack;
}
```

[735. 小行星碰撞](https://leetcode.cn/problems/asteroid-collision/)

```
vector<int> asteroidCollision(vector<int> &asteroids) {
    vector<int> stack;
    for (const auto &asteroid: asteroids) {
        stack.push_back(asteroid);
        bool collision = true;
        while (stack.size() >= 2 && stack[stack.size() - 2] > 0 && stack[stack.size() - 1] < 0 && collision) {
            if (stack[stack.size() - 2] == -stack[stack.size() - 1]) {
                stack.pop_back();
                stack.pop_back();
                collision = false;
            } else if (stack[stack.size() - 2] < -stack[stack.size() - 1]) {
                stack[stack.size() - 2] = stack[stack.size() - 1];
                stack.pop_back();
                collision = true;
            } else {
                stack.pop_back();
                collision = false;
            }
        }
    }
    return stack;
}
```

#### 括号匹配

[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

```
bool isValid(string s) {
    string stack;
    for (const auto &c: s) {
        if (c == '(' || c == '{' || c == '[') {
            stack.push_back(c);
        } else {
            if (!stack.empty() && (c == ')' && stack.back() == '(' || c == '}' && stack.back() == '{' || c == ']' && stack.back() == '[')) {
                stack.pop_back();
            } else {
                return false;
            }
        }
    }
    return stack.empty();
}
```

[921. 使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)

```
int minAddToMakeValid(string s) {
    int result = 0;
    string stack;
    for (const auto &c: s) {
        if (c == '(') {
            stack.push_back(c);
        } else {
            if (!stack.empty() && c == ')' && stack.back() == '(') {
                stack.pop_back();
            } else {
                if (!stack.empty()) {
                    stack.pop_back();
                }
                result++;
            }
        }
    }
    return result + stack.length();
}
```

[1021. 删除最外层的括号](https://leetcode.cn/problems/remove-outermost-parentheses/)

```
string removeOuterParentheses(string s) {
    string result;
    int depth = 0;
    for (const auto &c: s) {
        if (c == '(') {
            if (depth > 0) {
                result.push_back(c);
            }
            depth++;
        } else {
            if (depth > 1) {
                result.push_back(c);
            }
            depth--;
        }
    }
    return result;
}
```

[1614. 括号的最大嵌套深度](https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses/)

```
int maxDepth(string s) {
    int result = 0;
    int depth = 0;
    for (const auto &c: s) {
        if (c == '(') {
            depth++;
        } else if (c == ')') {
            depth--;
        }
        result = max(result, depth);
    }
    return result;
}
```

[1190. 反转每对括号间的子串](https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses/)

```
string reverseParentheses(string s) {
    string result;
    stack<string> stack;
    for (const auto &c: s) {
        if (isalpha(c)) {
            result += c;
        } else if (c == '(') {
            stack.push(result);
            result = "";
        } else {
            reverse(result.begin(), result.end());
            result = stack.top() + result;
            stack.pop();
        }
    }
    return result;
}
```

[856. 括号的分数](https://leetcode.cn/problems/score-of-parentheses/)

```
int scoreOfParentheses(string s) {
    stack<int> stack;
    for (const auto &c: s) {
        if (c == '(') {
            stack.push(0);
        } else {
            if (stack.top() == 0) {
                stack.pop();
                stack.push(1);
            } else {
                int sum = 0;
                while (!stack.empty() && stack.top() != 0) {
                    sum += stack.top();
                    stack.pop();
                }
                stack.pop();
                stack.push(2 * sum);
            }
        }
    }
    int result = 0;
    while (!stack.empty()) {
        result += stack.top();
        stack.pop();
    }
    return result;
}
```

[1249. 移除无效的括号](https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses/)

```
string minRemoveToMakeValid(string s) {
    set<int> indices;
    stack<int> stack;
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '(') {
            stack.push(i);
        } else if (s[i] == ')') {
            if (!stack.empty()) {
                stack.pop();
            } else {
                indices.insert(i);
            }
        }
    }
    while (!stack.empty()) {
        indices.insert(stack.top());
        stack.pop();
    }
    string result;
    for (int i = 0; i < s.length(); i++) {
        if (!indices.contains(i)) {
            result += s[i];
        }
    }
    return result;
}
```

[1963. 使字符串平衡的最小交换次数](https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-string-balanced/)

```
int minSwaps(string s) {
    int depth = 0;
    int result = 0;
    for (const auto &c: s) {
        if (c == '[') {
            depth++;
        } else {
            depth--;
        }
        result = min(result, depth);
    }
    return (-result + 1) / 2;
}
```

[678. 有效的括号字符串](https://leetcode.cn/problems/valid-parenthesis-string/)

```
bool checkValidString(string s) {
    stack<int> left;
    stack<int> star;
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '*') {
            star.push(i);
        } else if (s[i] == '(') {
            left.push(i);
        } else {
            if (!left.empty()) {
                left.pop();
            } else if (!star.empty()) {
                star.pop();
            } else {
                return false;
            }
        }
    }

    while (!left.empty() && !star.empty()) {
        if (left.top() > star.top()) {
            return false;
        }
        left.pop();
        star.pop();
    }

    return left.empty();
}
```

[1111. 有效括号的嵌套深度](https://leetcode.cn/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/)

```
vector<int> maxDepthAfterSplit(string seq) {
    vector<int> result(seq.length());
    int depth = 0;
    for (int i = 0; i < seq.length(); i++) {
        if (seq[i] == '(') {
            depth++;
            result[i] = depth % 2;
        } else {
            result[i] = depth % 2;
            depth--;
        }
    }
    return result;
}
```

[1541. 平衡括号字符串的最少插入次数](https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/)

```
int minInsertions(string s) {
    int result = 0;
    int sum = 0;
    for (const auto &c: s) {
        if (c == '(') {
            sum += 2;
            if (sum % 2 == 1) {
                result++;
                sum -= 1;
            }
        } else {
            sum -= 1;
            if (sum < 0) {
                result++;
                sum += 2;
            }
        }
    }
    return result + sum;
}
```

[32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

```
int longestValidParentheses(string s) {
    int result = 0;
    stack<int> stack;
    stack.push(-1);
    for (int i = 0; i < s.length(); i++) {
        if (s[i] == '(') {
            stack.push(i);
        } else {
            stack.pop();
            if (stack.empty()) {
                stack.push(i);
            } else {
                result = max(result, i - stack.top());
            }
        }
    }
    return result;
}
```

#### 表达式解析

[1006. 笨阶乘](https://leetcode.cn/problems/clumsy-factorial/)

```
string generate(int n) {
    string result = to_string(n);
    int op = 0;
    unordered_map<int, char> map = {
            {0, '*'},
            {1, '/'},
            {2, '+'},
            {3, '-'}
    };
    for (int i = n - 1; i >= 1; i--) {
        result += (map[op % 4] + to_string(i));
        op++;
    }
    return result;
}

int calculate(string s) {
    stack<int> numbers;
    stack<char> operators;
    unordered_map<char, int> priority = {
            {'+', 1},
            {'-', 1},
            {'*', 2},
            {'/', 2}
    };
    for (int i = 0; i < s.length(); i++) {
        if (isdigit(s[i])) {
            int n = 0;
            while (i < s.length() && isdigit(s[i])) {
                n = 10 * n + s[i] - '0';
                i++;
            }
            i--;
            numbers.push(n);
        } else {
            while (!operators.empty() && string strip(string s) {
        string result;
        for (const auto &c: s) {
            if (!isspace(c)) {
                result += c;
            }
        }
        return result;
    }

    string unarytobinary(string s) {
        string result;
        for (int i = 0; i < s.length(); i++) {
            if ((s[i] == '+' || s[i] == '-') && (i == 0 || !isdigit(s[i - 1]) && s[i - 1] != ')')) {
                result += '0';
            }
            result += s[i];
        }
        return result;
    }

    int calculate(string s) {
        s = strip(s);
        s = unarytobinary(s);
        stack<int> numbers;
        stack<char> operators;
        unordered_map<char, int> priority = {
                {'+', 1},
                {'-', 1},
                {'*', 2},
                {'/', 2}
        };
        for (int i = 0; i < s.length(); i++) {
            if (isdigit(s[i])) {
                long long n = 0;
                while (i < s.length() && isdigit(s[i])) {
                    n = 10 * n + s[i] - '0';
                    i++;
                }
                numbers.push(n);
                i--;
            } else if (s[i] == '(') {
                operators.push(s[i]);
            } else if (s[i] == ')') {
                while (!operators.empty() && operators.top() != '(') {
                    int right = numbers.top();
                    numbers.pop();
                    int left = numbers.top();
                    numbers.pop();
                    char oper = operators.top();
                    operators.pop();
                    switch (oper) {
                        case '+':
                            numbers.push(left + right);
                            break;
                        case '-':
                            numbers.push(left - right);
                            break;
                        case '*':
                            numbers.push(left * right);
                            break;
                        case '/':
                            numbers.push(left / right);
                            break;
                    }
                }
                operators.pop();
            } else {
                while (!operators.empty() && operators.top() != '(' && priority[operators.top()] >= priority[s[i]]) {
                    int right = numbers.top();
                    numbers.pop();
                    int left = numbers.top();
                    numbers.pop();
                    char oper = operators.top();
                    operators.pop();
                    switch (oper) {
                        case '+':
                            numbers.push(left + right);
                            break;
                        case '-':
                            numbers.push(left - right);
                            break;
                        case '*':
                            numbers.push(left * right);
                            break;
                        case '/':
                            numbers.push(left / right);
                            break;
                    }
                }
                operators.push(s[i]);
            }
        }
        while (!operators.empty()) {
            int right = numbers.top();
            numbers.pop();
            int left = numbers.top();
            numbers.pop();
            char oper = operators.top();
            operators.pop();
            switch (oper) {
                case '+':
                    numbers.push(left + right);
                    break;
                case '-':
                    numbers.push(left - right);
                    break;
                case '*':
                    numbers.push(left * right);
                    break;
                case '/':
                    numbers.push(left / right);
                    break;
            }
        }
        return numbers.top();
    }) {
                int right = numbers.top();
                numbers.pop();
                int left = numbers.top();
                numbers.pop();
                char oper = operators.top();
                operators.pop();
                switch (oper) {
                    case '+':
                        numbers.push(left + right);
                        break;
                    case '-':
                        numbers.push(left - right);
                        break;
                    case '*':
                        numbers.push(left * right);
                        break;
                    case '/':
                        numbers.push(left / right);
                        break;
                }
            }
            operators.push(s[i]);
        }
    }
    while (!operators.empty()) {
        int right = numbers.top();
        numbers.pop();
        int left = numbers.top();
        numbers.pop();
        char oper = operators.top();
        operators.pop();
        switch (oper) {
            case '+':
                numbers.push(left + right);
                break;
            case '-':
                numbers.push(left - right);
                break;
            case '*':
                numbers.push(left * right);
                break;
            case '/':
                numbers.push(left / right);
                break;
        }
    }
    return numbers.top();
}

int clumsy(int n) {
    return calculate(generate(n));
}
```

[150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

```
int evalRPN(vector<string> &tokens) {
    stack<string> stack;
    for (const auto &token: tokens) {
        if (isdigit(token.back())) {
            stack.push(token);
        } else {
            int right = stoi(stack.top());
            stack.pop();
            int left = stoi(stack.top());
            stack.pop();
            if (token.front() == '+') {
                stack.push(to_string(left + right));
            } else if (token.front() == '-') {
                stack.push(to_string(left - right));
            } else if (token.front() == '*') {
                stack.push(to_string(left * right));
            } else {
                stack.push(to_string(left / right));
            }
        }
    }
    return stoi(stack.top());
}
```

[394. 字符串解码](https://leetcode.cn/problems/decode-string/)



[224. 基本计算器](https://leetcode.cn/problems/basic-calculator/)

```
string strip(string s) {
    string result;
    for (const auto &c: s) {
        if (!isspace(c)) {
            result += c;
        }
    }
    return result;
}

string unarytobinary(string s) {
    string result;
    for (int i = 0; i < s.length(); i++) {
        if ((s[i] == '+' || s[i] == '-') && (i == 0 || !isdigit(s[i - 1]) && s[i - 1] != ')')) {
            result += '0';
        }
        result += s[i];
    }
    return result;
}

int calculate(string s) {
    s = strip(s);
    s = unarytobinary(s);
    stack<int> numbers;
    stack<char> operators;
    for (int i = 0; i < s.length(); i++) {
        if (isdigit(s[i])) {
            long long n = 0;
            while (i < s.length() && isdigit(s[i])) {
                n = 10 * n + s[i] - '0';
                i++;
            }
            numbers.push(n);
            i--;
        } else if (s[i] == '(') {
            operators.push(s[i]);
        } else if (s[i] == ')') {
            while (!operators.empty() && operators.top() != '(') {
                int right = numbers.top();
                numbers.pop();
                int left = numbers.top();
                numbers.pop();
                char oper = operators.top();
                operators.pop();
                switch (oper) {
                    case '+':
                        numbers.push(left + right);
                        break;
                    case '-':
                        numbers.push(left - right);
                        break;
                }
            }
            operators.pop();
        } else {
            while (!operators.empty() && operators.top() != '(') {
                int right = numbers.top();
                numbers.pop();
                int left = numbers.top();
                numbers.pop();
                char oper = operators.top();
                operators.pop();
                switch (oper) {
                    case '+':
                        numbers.push(left + right);
                        break;
                    case '-':
                        numbers.push(left - right);
                        break;
                }
            }
            operators.push(s[i]);
        }
    }
    while (!operators.empty()) {
        int right = numbers.top();
        numbers.pop();
        int left = numbers.top();
        numbers.pop();
        char oper = operators.top();
        operators.pop();
        switch (oper) {
            case '+':
                numbers.push(left + right);
                break;
            case '-':
                numbers.push(left - right);
                break;
        }
    }
    return numbers.top();
}
```

[227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)

```
string strip(string s) {
    string result;
    for (const auto &c: s) {
        if (!isspace(c)) {
            result += c;
        }
    }
    return result;
}

string unarytobinary(string s) {
    string result;
    for (int i = 0; i < s.length(); i++) {
        if ((s[i] == '+' || s[i] == '-') && (i == 0 || !isdigit(s[i - 1]) && s[i - 1] != ')')) {
            result += '0';
        }
        result += s[i];
    }
    return result;
}

int calculate(string s) {
    s = strip(s);
    s = unarytobinary(s);
    stack<int> numbers;
    stack<char> operators;
    unordered_map<char, int> priority = {
            {'+', 1},
            {'-', 1},
            {'*', 2},
            {'/', 2}
    };
    for (int i = 0; i < s.length(); i++) {
        if (isdigit(s[i])) {
            long long n = 0;
            while (i < s.length() && isdigit(s[i])) {
                n = 10 * n + s[i] - '0';
                i++;
            }
            numbers.push(n);
            i--;
        } else if (s[i] == '(') {
            operators.push(s[i]);
        } else if (s[i] == ')') {
            while (!operators.empty() && operators.top() != '(') {
                int right = numbers.top();
                numbers.pop();
                int left = numbers.top();
                numbers.pop();
                char oper = operators.top();
                operators.pop();
                switch (oper) {
                    case '+':
                        numbers.push(left + right);
                        break;
                    case '-':
                        numbers.push(left - right);
                        break;
                    case '*':
                        numbers.push(left * right);
                        break;
                    case '/':
                        numbers.push(left / right);
                        break;
                }
            }
            operators.pop();
        } else {
            while (!operators.empty() && operators.top() != '(' && priority[operators.top()] >= priority[s[i]]) {
                int right = numbers.top();
                numbers.pop();
                int left = numbers.top();
                numbers.pop();
                char oper = operators.top();
                operators.pop();
                switch (oper) {
                    case '+':
                        numbers.push(left + right);
                        break;
                    case '-':
                        numbers.push(left - right);
                        break;
                    case '*':
                        numbers.push(left * right);
                        break;
                    case '/':
                        numbers.push(left / right);
                        break;
                }
            }
            operators.push(s[i]);
        }
    }
    while (!operators.empty()) {
        int right = numbers.top();
        numbers.pop();
        int left = numbers.top();
        numbers.pop();
        char oper = operators.top();
        operators.pop();
        switch (oper) {
            case '+':
                numbers.push(left + right);
                break;
            case '-':
                numbers.push(left - right);
                break;
            case '*':
                numbers.push(left * right);
                break;
            case '/':
                numbers.push(left / right);
                break;
        }
    }
    return numbers.top();
}
```

#### 对顶栈

[2296. 设计一个文本编辑器](https://leetcode.cn/problems/design-a-text-editor/)

```
class TextEditor {
private:
    string left;
    string right;

public:
    TextEditor() {}

    void addText(string text) {
        left += text;
    }

    int deleteText(int k) {
        k = min(k, static_cast<int>(left.length()));
        left.resize(left.length() - k);
        return k;
    }

    string cursorLeft(int k) {
        while (k && !left.empty()) {
            right += left.back();
            left.pop_back();
            k--;
        }
        return left.substr(max(static_cast<int>(left.length()) - 10, 0));
    }

    string cursorRight(int k) {
        while (k && !right.empty()) {
            left += right.back();
            right.pop_back();
            k--;
        }
        return left.substr(max(static_cast<int>(left.length()) - 10, 0));
    }
};
```

#### 单调栈

##### 单调栈

[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

```
vector<int> dailyTemperatures(vector<int> &temperatures) {
    vector<int> result(temperatures.size());
    stack<int> stack;
    for (int i = temperatures.size() - 1; i >= 0; i--) {
        while (!stack.empty() && temperatures[stack.top()] <= temperatures[i]) {
            stack.pop();
        }
        result[i] = stack.empty() ? 0 : stack.top() - i;
        stack.push(i);
    }
    return result;
}
```

[1475. 商品折扣后的最终价格](https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/)

```
vector<int> finalPrices(vector<int> &prices) {
    vector<int> result(prices.size());
    stack<int> stack;
    for (int i = prices.size() - 1; i >= 0; i--) {
        result[i] = prices[i];
        while (!stack.empty() && prices[stack.top()] > prices[i]) {
            stack.pop();
        }
        result[i] = stack.empty() ? prices[i] : prices[i] - prices[stack.top()];
        stack.push(i);
    }
    return result;
}
```

[496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

```
vector<int> nextGreaterElement(vector<int> &nums1, vector<int> &nums2) {
    unordered_map<int, int> map;
    stack<int> stack;
    for (int i = nums2.size() - 1; i >= 0; i--) {
        while (!stack.empty() && nums2[stack.top()] <= nums2[i]) {
            stack.pop();
        }
        map[nums2[i]] = stack.empty() ? -1 : nums2[stack.top()];
        stack.push(i);
    }
    vector<int> result(nums1.size());
    for (int i = 0; i < nums1.size(); i++) {
        result[i] = map[nums1[i]];
    }
    return result;
}
```

[503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

```
vector<int> nextGreaterElements(vector<int> &nums) {
    vector<int> result(nums.size());
    stack<int> stack;
    for (int i = nums.size() - 1; i >= 0; i--) {
        stack.push(i);
    }
    for (int i = nums.size() - 1; i >= 0; i--) {
        while (!stack.empty() && nums[stack.top()] <= nums[i]) {
            stack.pop();
        }
        result[i] = stack.empty() ? -1 : nums[stack.top()];
        stack.push(i);
    }
    return result;
}
```

[901. 股票价格跨度](https://leetcode.cn/problems/online-stock-span/)

```
class StockSpanner {
private:
    vector<int> stock;
    stack<int> stack;

public:
    StockSpanner() {}

    int next(int price) {
        stock.push_back(price);
        int result = 1;
        while (!stack.empty() && stock[stack.top()] <= price) {
            stack.pop();
        }
        result = stack.empty() ? stock.size() : stock.size() - stack.top() - 1;
        stack.push(stock.size() - 1);
        return result;
    }
};
```

[853. 车队](https://leetcode.cn/problems/car-fleet/)

```
int carFleet(int target, vector<int> &position, vector<int> &speed) {
    vector<pair<int, int>> cars(position.size());
    for (int i = 0; i < position.size(); i++) {
        cars[i] = make_pair(position[i], speed[i]);
    }
    sort(cars.begin(), cars.end(), [](const pair<int, int> &a, const pair<int, int> &b) { return a.first > b.first; });
    stack<double> stack;
    for (const auto &car: cars) {
        double time = 1.0f * (target - car.first) / car.second;
        if (!stack.empty() && stack.top() >= time) {
            continue;
        }
        stack.push(time);
    }
    return stack.size();
}
```

##### 矩形

[84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

```
int largestRectangleArea(vector<int> &heights) {
    vector<int> left(heights.size());
    stack<int> lstack;
    for (int i = 0; i < heights.size(); i++) {
        while (!lstack.empty() && heights[lstack.top()] >= heights[i]) {
            lstack.pop();
        }
        left[i] = lstack.empty() ? -1 : lstack.top();
        lstack.push(i);
    }

    vector<int> right(heights.size());
    stack<int> rstack;
    for (int i = heights.size() - 1; i >= 0; i--) {
        while (!rstack.empty() && heights[rstack.top()] >= heights[i]) {
            rstack.pop();
        }
        right[i] = rstack.empty() ? heights.size() : rstack.top();
        rstack.push(i);
    }

    int result = 0;
    for (int i = 0; i < heights.size(); i++) {
        result = max(result, heights[i] * (right[i] - left[i] - 1));
    }
    return result;
}
```

##### 贡献法

[907. 子数组的最小值之和](https://leetcode.cn/problems/sum-of-subarray-minimums/)

```
int sumSubarrayMins(vector<int> &arr) {
    vector<int> left(arr.size());
    stack<int> lstack;
    for (int i = 0; i < arr.size(); i++) {
        while (!lstack.empty() && arr[lstack.top()] >= arr[i]) {
            lstack.pop();
        }
        left[i] = lstack.empty() ? -1 : lstack.top();
        lstack.push(i);
    }

    vector<int> right(arr.size());
    stack<int> rstack;
    for (int i = arr.size() - 1; i >= 0; i--) {
        while (!rstack.empty() && arr[rstack.top()] > arr[i]) {
            rstack.pop();
        }
        right[i] = rstack.empty() ? arr.size() : rstack.top();
        rstack.push(i);
    }

    long long result = 0;
    const int MOD = 1e9 + 7;
    for (int i = 0; i < arr.size(); i++) {
        result += 1LL * arr[i] * (i - left[i]) * (right[i] - i);
    }
    return result % MOD;
}
```

##### 最小字典序

[402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/)

```
string removeKdigits(string num, int k) {
    stack<int> stack;
    for (int i = 0; i < num.length(); i++) {
        while (k && !stack.empty() && num[stack.top()] > num[i]) {
            stack.pop();
            k--;
        }
        if (stack.empty() && num[i] == '0') {
            continue;
        }
        stack.push(i);
    }

    while (k && !stack.empty()) {
        stack.pop();
        k--;
    }

    string result = "";
    while (!stack.empty()) {
        result += num[stack.top()];
        stack.pop();
    }
    reverse(result.begin(), result.end());
    return result.empty() ? "0" : result;
}
```

### 队列

#### 队列

[933. 最近的请求次数](https://leetcode.cn/problems/number-of-recent-calls/)

```
class RecentCounter {
private:
    queue<int> queue;

public:
    RecentCounter() {}

    int ping(int t) {
        while (!queue.empty() && queue.front() < t - 3000) {
            queue.pop();
        }
        queue.push(t);
        return queue.size();
    }
};
```

[950. 按递增顺序显示卡牌](https://leetcode.cn/problems/reveal-cards-in-increasing-order/)

```
vector<int> deckRevealedIncreasing(vector<int> &deck) {
    sort(deck.begin(), deck.end());
    queue<int> queue;
    for (int i = deck.size() - 1; i >= 0; i--) {
        queue.push(deck[i]);
        if (i == 0) {
            break;
        }
        queue.push(queue.front());
        queue.pop();
    }
    vector<int> result(deck.size());
    for (int i = deck.size() - 1; i >= 0; i--) {
        result[i] = queue.front();
        queue.pop();
    }
    return result;
}
```

[649. Dota2 参议院](https://leetcode.cn/problems/dota2-senate/)

```
string predictPartyVictory(string senate) {
    queue<int> radiant;
    queue<int> dire;
    for (int i = 0; i < senate.length(); i++) {
        if (senate[i] == 'R') {
            radiant.push(i);
        } else {
            dire.push(i);
        }
    }

    while (!radiant.empty() && !dire.empty()) {
        if (radiant.front() < dire.front()) {
            radiant.push(radiant.front() + senate.size());
        } else {
            dire.push(dire.front() + senate.size());
        }
        radiant.pop();
        dire.pop();
    }
    return !radiant.empty() ? "Radiant" : "Dire";
}
```

#### 设计队列

[1670. 设计前中后队列](https://leetcode.cn/problems/design-front-middle-back-queue/)

```
class FrontMiddleBackQueue {
private:
    deque<int> left;
    deque<int> right;

private:
    void balance() {
        if (left.size() > right.size()) {
            right.push_front(left.back());
            left.pop_back();
        } else if (right.size() > left.size() + 1) {
            left.push_back(right.front());
            right.pop_front();
        }
    }

public:
    FrontMiddleBackQueue() {}

    void pushFront(int val) {
        left.push_front(val);
        balance();
    }

    void pushMiddle(int val) {
        if (left.size() >= right.size()) {
            right.push_front(val);
        } else {
            left.push_back(val);
        }
    }

    void pushBack(int val) {
        right.push_back(val);
        balance();
    }

    int popFront() {
        if (right.empty()) {
            return -1;
        }
        int val;
        if (left.empty()) {
            val = right.front();
            right.pop_front();
        } else {
            val = left.front();
            left.pop_front();
        }
        balance();
        return val;
    }

    int popMiddle() {
        if (right.empty()) {
            return -1;
        }
        int val;
        if (left.size() == right.size()) {
            val = left.back();
            left.pop_back();
        } else {
            val = right.front();
            right.pop_front();
        }
        return val;
    }

    int popBack() {
        if (right.empty()) {
            return -1;
        }
        int val = right.back();
        right.pop_back();
        balance();
        return val;
    }
};
```

[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

```
class MyStack {
private:
    queue<int> queue;

public:
    MyStack() {}

    void push(int x) {
        queue.push(x);
    }

    int pop() {
        for (int size = queue.size(); size > 1; size--) {
            queue.push(queue.front());
            queue.pop();
        }
        int result = queue.front();
        queue.pop();
        return result;
    }

    int top() {
        return queue.back();
    }

    bool empty() {
        return queue.empty();
    }
};
```

[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

```
class MyQueue {
private:
    stack<int> stack1;
    stack<int> stack2;

public:
    MyQueue() {

    }

    void push(int x) {
        stack1.push(x);
    }

    int pop() {
        while (!stack1.empty()) {
            stack2.push(stack1.top());
            stack1.pop();
        }
        int result = stack2.top();
        stack2.pop();
        while (!stack2.empty()) {
            stack1.push(stack2.top());
            stack2.pop();
        }
        return result;
    }

    int peek() {
        while (!stack1.empty()) {
            stack2.push(stack1.top());
            stack1.pop();
        }
        int result = stack2.top();
        while (!stack2.empty()) {
            stack1.push(stack2.top());
            stack2.pop();
        }
        return result;
    }

    bool empty() {
        return stack1.empty();
    }
};
```

[622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/)

```
class MyCircularQueue {
private:
    int front;
    int rear;
    int capacity;
    vector<int> queue;

public:
    MyCircularQueue(int k) {
        front = 0;
        rear = 0;
        capacity = k + 1;
        queue = vector<int>(capacity);
    }

    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        queue[rear] = value;
        rear = (rear + 1) % capacity;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        int value = queue[front];
        front = (front + 1) % capacity;
        return true;
    }

    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return queue[front];
    }

    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return queue[(rear - 1 + capacity) % capacity];
    }

    bool isEmpty() {
        return front == rear;
    }

    bool isFull() {
        return (rear + 1) % capacity == front;
    }
};
```

[641. 设计循环双端队列](https://leetcode.cn/problems/design-circular-deque/)

```
class MyCircularDeque {
private:
    int front;
    int rear;
    int capacity;
    deque<int> queue;

public:
    MyCircularDeque(int k) {
        front = 0;
        rear = 0;
        capacity = k + 1;
        queue = deque<int>(capacity);
    }

    bool insertFront(int value) {
        if (isFull()) {
            return false;
        }
        front = (front - 1 + capacity) % capacity;
        queue[front] = value;
        return true;
    }

    bool insertLast(int value) {
        if (isFull()) {
            return false;
        }
        queue[rear] = value;
        rear = (rear + 1) % capacity;
        return true;
    }

    bool deleteFront() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        return true;
    }

    bool deleteLast() {
        if (isEmpty()) {
            return false;
        }
        rear = (rear - 1 + capacity) % capacity;
        return true;
    }

    int getFront() {
        if (isEmpty()) {
            return -1;
        }
        return queue[front];
    }

    int getRear() {
        if (isEmpty()) {
            return -1;
        }
        return queue[(rear - 1 + capacity) % capacity];
    }

    bool isEmpty() {
        return front == rear;
    }

    bool isFull() {
        return (rear + 1) % capacity == front;
    }
};
```

#### 双端队列

[2810. 故障键盘](https://leetcode.cn/problems/faulty-keyboard/)

```
string finalString(string s) {
    string result;
    for (const auto &c: s) {
        if (c != 'i') {
            result += c;
        } else {
            reverse(result.begin(), result.end());
        }
    }
    return result;
}
```

#### 单调队列

[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)



[LCR 184. 设计自助结算系统](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/)



[1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)



[2762. 不间断子数组](https://leetcode.cn/problems/continuous-subarrays/)



### 堆

#### 堆

[1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/)

```
int lastStoneWeight(vector<int> &stones) {
    priority_queue<int, vector<int>> pq(stones.begin(),stones.end());
    while (pq.size() > 1) {
        int a = pq.top();
        pq.pop();
        int b = pq.top();
        pq.pop();
        if (a > b) {
            pq.push(a - b);
        }
    }
    return pq.empty() ? 0 : pq.top();
}
```

#### 重排元素

#### 第K小/第K大

#### 反悔堆

#### 懒删除堆

#### 对顶堆

### 字典树

#### 字典树

#### 字典树优化DP

#### 0-1字典树

### 并查集

#### 并查集

#### GCD并查集

#### 数组并查集

#### 区间并查集

#### 边权并查集

### 树状数组

#### 树状数组

### 逆序对

#### 逆序对

### 线段树

#### 线段树

#### Lazy线段树

#### 动态开点线段树

#### 珂朵莉树

#### 伸展树（Splay树）

### 根号算法

#### 根号分解

#### 莫队算法

### 离线算法

## 链表



## 二叉树



## 字符串



## 回溯



## 网格图



## 位运算



## 图论



## 动态规划



## 贪心

